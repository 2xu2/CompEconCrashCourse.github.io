[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Computational Crash Course for Economics PhD Students, Summer 2024 (UMN)",
    "section": "",
    "text": "Disclaimer: this site is a work in progress!\nWelcome to the 2024 summer course on computational economics at UMN! It will be a 3-week crash course consisting of 2 Julia and 2 Python lectures each week. The Julia lectures will be taught by Xing Xu and the Python lectures will be taught by Adam Oppenheimer. Find the detailed syllabus and information below.\nAll the notebooks for lectures and assignments can be downloaded from Github repo."
  },
  {
    "objectID": "index.html#topics",
    "href": "index.html#topics",
    "title": "Computational Crash Course for Economics PhD Students, Summer 2024 (UMN)",
    "section": "Topics",
    "text": "Topics\nThe courses will have different focuses, with the Julia lectures focusing more on computational methods and their implementations on different types of classic economic models and the Python lectures focusing on programming basics, building up fundamental tools that will culminate in solving simple dynamic programming models. Nevertheless, the classes will be complementary to each other as the skills learned can be applied to any programming languages.\nThe classes are designed to be introductory, with no prior knowledge on programming required.\n\nJulia\nThe 6 Julia lectures are arranged as follows:\n\n\nPython"
  },
  {
    "objectID": "index.html#assessment",
    "href": "index.html#assessment",
    "title": "Computational Crash Course for Economics PhD Students, Summer 2024 (UMN)",
    "section": "Assessment",
    "text": "Assessment\nThere will be 7 problem sets. Your best 5 of these 7 problem sets will be worth 20%. Hence, you can skip two if you want.\nHere is the proposed timeline of due dates. Submissions must be made through Canvas as a notebook (e.g. jupyter or quarto) formatted to html with printed output.\n\n\n\nAssignment\nDue Date\n\n\n\n\nAssignment 1\nMarch 22\n\n\nAssignment 2\nMarch 29\n\n\nAssignment 3\nApril 5\n\n\nAssignment 4\nApril 12\n\n\nAssignment 5\nApril 19 April 26\n\n\nAssignment 6\nApril 26 May 3\n\n\nAssignment 7\nMay 3 May 10"
  },
  {
    "objectID": "index.html#office-hours",
    "href": "index.html#office-hours",
    "title": "Computational Crash Course for Economics PhD Students, Summer 2024 (UMN)",
    "section": "Office Hours",
    "text": "Office Hours\nWe will provide links to sign up for weekly office hours."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "Julia/Lectures/Julia_Lec_4_Compecon_Xing_Xu.html",
    "href": "Julia/Lectures/Julia_Lec_4_Compecon_Xing_Xu.html",
    "title": "Lecture 4: Incomplete market models with transition dynamics",
    "section": "",
    "text": "In this lecture, I introduce the basic set-up of the workhorse incomplete market model – the Aiyagari model and discuss how to compute it numerically. When writing this lecture, I largely follow from my answer for problem set 3 and 4 for Manuel Amador’s Macro class.\nUseful notes: Jesus Fernandez-Villaverde’s notes on heterogeneous agent models: part 1, part 2, part 3.\n\nGeneral set up of the Aiyagari model\n\nEnvironment:\n\nHousehold:\nContinuum of household with mass 1:\nHousehold has identical preferences: \\[\n\\sum_{t=0}^\\infty \\beta^t u(c_t)\n\\],\nsubject to a budget constraint: \\(c_t + a_{t+1} \\leq w_t l_t(s^t) + R_t a_t, \\forall t\\),\nand a borrowing limit: \\(a_{t + 1} \\geq \\phi, \\forall t\\),\nwith \\(a_0, l_0 \\geq 0\\) given.\n\nLet labor endowments for each household follow a markov chain with a transition matrix \\(\\pi\\), \\(\\pi(s'|s) &gt; 0, \\forall s, s'\\). The invariant distribution of labor supply is a probability distribution \\(\\lambda\\) such that \\(\\lambda \\pi = \\pi\\).\nBy law of large number, the aggregate labor supply \\(L = \\sum_{s \\in S} \\lambda(s) l(s)\\) does not depend on \\(s\\) (no aggregate uncertainty). This is a key feature of the problem.\n\n\n\nFirm:\nA perfectly competitive firm with Neo-classical technology: \\[\nY_t = F(K_t, L_t).\n\\]\n\n\nAggregate resource constraint:\n\\[\nC_t + K_{t+1} - (1 - \\delta) K_t = F(K_t, L)\n\\] with depreciation rate \\(\\delta \\in (0,1)\\).\n\n\n\n\nRecursive formulation of the household problem\nAssume utility is strictly increasing. Taking the interest rate \\(R\\) and \\(w\\) as given, the household problem takes the recursive form:\n\\(V(a, s) = \\max_{a'\\geq \\phi} u(Ra + w l(s) - a') + \\beta E[V(a', s')]\\)\nwhere \\(s\\) is the realization of the labor endowment today.\n\nSide notes on alternative specification of the household problem:\nAlternatively we can write the problem as \\(V(x, s) = \\max_{a'\\geq \\phi} u(x - a') + \\beta E[V(Ra' + w l(s'), s')]\\), where \\(x \\equiv Ra + w l(s)\\) is the cash in hand today. Note that the value function will be different as it is now a function of \\(x\\). The key here is that one need to make sure that the state variables on both sides are consistent.\nOn top of this, Aiyagari used a trick to simplify the problem. Define \\(\\hat{a} = a + \\phi\\), \\(\\hat{x} = x + \\phi\\). Then, the household problem can be rewritten as:\n\\(v(\\hat{x}, s) = \\max_{\\hat{a}' \\geq 0} u(\\hat{x} - \\hat{a}') + \\beta E[v(R\\hat{a}' + w l(s') - (R - 1) \\phi), s']\\)\n\nNow let’s try to solve the household problem using \\(a\\) as the first state variable given particular \\(R\\) and \\(w\\). This is essentially a partial equilibrium and is often referred to as a Bewley/Hugget model.\n\n\n\nComputing the Bewley/Hugget Model\nNote that here only the product of \\(w\\) and \\(l\\) matters here and there’s no interesting mechanism for determining \\(w\\). For simplicity, we define \\(y(s) \\equiv wl(s)\\) such that \\(V(a, s) = \\max_{a'\\geq \\phi} u(Ra + y(s) - a') + \\beta E[V(a', s')]\\). Further assume \\(s\\) follows a first-order markov chain governed by states \\(y(s)\\) and transition matrix \\(P\\).\nWe will construct grids using \\(a\\). Let \\(a\\) start from \\(\\phi\\) so the agent cannot over-borrow.\nThe following codes are adopted from problem set 2 and 3 from Manuel Amador’s Macro class.\nAs before, Base.@kwdef struct is used to store the parameters. However here instead of some specific types like Float64, we use parametric types like R1 and T1. These can really be any types dependent on the input. Check the documentation for parametric types here.\n\nusing LinearAlgebra\nusing Plots\n\n\nBase.@kwdef struct Household{T1, T2, T3, R1, S}\n    β::R1 = 0.95\n    ρ::R1 = 2.0 \n    ϕ::R1 = 0.0  # The borrowing limit is zero \n    P::T1 = [0.5 0.5; 0.2 0.8] # transition matrix for state s\n    l::T2 = [0.5, 1.0] # labor endowment: l(s) (normalize w to 1.0 so that y(s) = l(s))\n    a_min::R1 = ϕ\n    a_max::R1 = 5.0\n    points::S = 10_000\n    \n    a_grid::T3 = range(a_min, a_max, points)\nend\n\nu(c, m) = c ^ (1 - m.ρ) / (1 - m.ρ)  \nuprime(c, m) = c ^ (-m.ρ) \n\nuprime (generic function with 1 method)\n\n\nNow solve the value function as before. Since we have two states now, we need a matrix to store the value and policy for each different combination of \\(a\\) and \\(y\\).\nThere are mainly two tricks in the code. The first is to pre-compute the expected discounted value for each \\(a'\\) and \\(s'\\) conditional on \\(s\\) within the outer loop. The second is to take use of the fact of strictly increasing policy function as we have seen in Lecture 2.\n\nfunction solve_household(h; R = 0.9, w = 1.0, v0 = zeros(length(h.a_grid), length(h.l)),  tol = 1e-6)\n    \n    # unpacking \n    (; a_grid, l, β, P) = h\n    \n    v1 = similar(v0)\n    pol = similar(v0, Int)\n    βv = similar(v1)\n    \n    n = length(a_grid)\n    \n    iter = 0\n    while true\n        distance = zero(eltype(v0))\n        iter += 1 \n        \n        # Precompute βE[V(a', s')] for better performance\n        for s in eachindex(l)\n            for i in eachindex(a_grid)\n                accum = zero(eltype(v0))\n                for sprime in eachindex(l)\n                    accum += β * P[s, sprime] * v0[i, sprime]\n                end\n                βv[i, s] = accum\n            end \n        end\n        # or simply βv = β .* v0 * P' \n\n        for s in eachindex(l) \n            pol_i = 1\n            for i in eachindex(a_grid)\n                just_started = true \n                vmax = zero(eltype(v0))\n                for j in pol_i:n #take use of strictly increasing policy function\n                    c = R * a_grid[i] + w*l[s] - a_grid[j]\n                    if c &gt; 0.0\n                        v_tmp = u(c, h) + βv[j, s]\n                        if just_started\n                            vmax = v_tmp\n                            pol_i = j\n                            just_started = false\n                        elseif v_tmp &gt; vmax \n                            vmax = v_tmp \n                            pol_i = j\n                        else \n                            break \n                        end \n                    end \n                end \n                v1[i, s] = vmax\n                pol[i, s] = pol_i\n                dis = abs(vmax - v0[i, s])\n                if dis &gt; distance\n                    distance = dis\n                end \n            end \n        end \n        \n        if distance &lt; tol\n            break\n        else \n            v0 .= v1\n        end \n    end \n    return (v = v1, pol = pol, h = h, R = R, w = w)\nend \n    \n\nsolve_household (generic function with 1 method)\n\n\nExplanations over how the code works (GPT generated, which is actually pretty good):\nThis function solve_household solves the household problem defined earlier using value function iteration. The function takes in the model parameters as input, par, and some optional arguments such as an initial guess for the value function v0 and a tolerance level tol.\nThe function initializes some variables such as v1 and pol as arrays of zeros with the same shape as v0, which is the value function from the previous iteration. βv is also initialized as an array of zeros, which will be used to store the expected value of the next iteration.\nThe function then performs the value function iteration using a nested loop over ytilde and ahat_grid. The inner loop first computes the expected value of the next iteration using the Bellman equation and stores it in βv.\nThe inner loop then maximizes the Bellman equation over the choice of next period asset holding ahat_grid[j] using a nested loop that starts at pol_i. This is done to take advantage of the fact that the optimal choice of ahat_grid[j] is increasing in j. The loop computes the value of the Bellman equation for each ahat_grid[j] and stops once the first ahat_grid[j] is found that yields a negative consumption level c. The function then stores the optimal value function vmax and the corresponding choice of j in pol_i and moves on to the next ahat_grid[i].\nThe function then computes the distance between the value function from the current iteration v0 and the value function from the previous iteration v1. If the distance is less than the tolerance level tol, the function exits the loop and returns the value function v1, the policy function pol, and the model parameters m.\nOverall, the function uses a nested loop to solve the household problem using value function iteration, and it takes advantage of the fact that the problem has a recursive structure and a simple functional form for the utility function to compute the optimal value and policy functions efficiently.\n\nh = Household() # struct with default parameter values\nsol_1 = solve_household(h, R = 0.658) #input some random R. \n\n(v = [-26.71326843693425 -25.314667038332857; -26.711953170852723 -25.314338113656607; … ; -24.019524603316466 -23.72455416253825; -24.019409824729976 -23.72445885993552], pol = [1 1; 1 1; … ; 4194 4864; 4194 4864], h = Household{Matrix{Float64}, Vector{Float64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, Float64, Int64}(0.95, 2.0, 0.0, [0.5 0.5; 0.2 0.8], [0.5, 1.0], 0.0, 5.0, 10000, 0.0:0.0005000500050005:5.0), R = 0.658, w = 1.0)\n\n\nLet’s take a look at the value function and policy functions\n\nfunction do_v_plot(sol_1)\n\n    income = sol_1.w * sol_1.h.l \n    p1 = Plots.plot(xlabel = \"Current saving, a\", ylabel = \"Value, v\")\n    for i in eachindex(income)\n        temp = income[i]\n        plot!(p1, sol_1.h.a_grid, sol_1.v[:,i], label = \"y = $temp\")\n    end\n    \n    return p1\nend\n\ndo_v_plot(sol_1)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction do_pol_plot(sol_1)\n\n    (; pol, h)= sol_1 \n\n    p1 = Plots.plot(xlabel = \"Current saving, a\", ylabel = \"Saving next period, a' \")\n    for s in eachindex(h.l)\n        temp = sol_1.w * h.l[s]\n        yvals = [[h.a_grid[pol[i, s]] for i in eachindex(h.a_grid)]]\n        plot!(p1, sol_1.h.a_grid, yvals, label = \"y = $temp\")\n    end\n    \n    return p1\nend\n\ndo_pol_plot(sol_1)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote that when \\(y\\) is low. The policy function for \\(a'\\) is flat. The intuition is that the agent has incentive to borrow for consumption smoothing when endowment is low (why?) but is borrowing constrained due to the \\(0\\) borrowing limit. As a result, the agent consumes all her endowment. This is sometimes referred to as “Hand-to-mouth” consumption.\n\n\nRecursive competitive equilibrium (Aiyagari 1994)\nWith some understanding of the partial equilibrium, we now try to build towards the general equilibrium. With household optimality, firm optimality and market clearing conditions, the equilibrium can be formally defined by a recursive competitive equilibrium.\nThe key difference is that every household now needs to know the distribution of everyone else’s asset holdings to infer future interest rate.\nLet \\(a \\in A \\equiv [\\phi, \\infty]\\), \\(s \\in S\\). From the recursive form of the household problem, for given R we can solve for a value function \\(v(a, s): A \\times S \\to R\\) and a policy function for saving \\(g(a, s): A \\times S \\to A\\).\n\nPrices in general equilibrium\nNow for simplicity, let the firm technology be characterized by a CRS Cobb-Douglas production function, i.e. \\[\nY_t = A K_t^\\alpha L_t^{1 - \\alpha}.\n\\]\nThe firm’s problem takes the form: (why?)\n\\[\\max_{K_t, L_t} A K_t^\\alpha L_t^{1 - \\alpha} - (R_t -1 +\\delta) K_t - w_t L_t\\]\nFirm’s first order conditions: \\[\n\\begin{cases}\nR_t = A \\alpha K_t^{\\alpha - 1} L_t^{1 - \\alpha} +1 - \\delta \\\\\nw_t = A (1 - \\alpha) K_t^\\alpha L_t^{-\\alpha}\n\\end{cases}\n\\]\nNote that \\(w\\) can be pinned down by \\(R\\) in equilibrium: \\[\nw_t(R_t) = A^{\\frac{1}{1-\\alpha}} (1 - \\alpha) \\alpha^{\\frac{\\alpha}{1 - \\alpha}} \\left(R_t - 1 +\\delta \\right)^{\\frac{\\alpha}{1 - \\alpha}}\n\\]\nThis is very handy when it comes to computing the equilibrium prices.\n\n\n\nStationary Competitive Equilibrium\n\nSet up of a (recursive) stationary competitive equilibrium\nA stationary competitive equilibrium is defined by a system of constant prices (interest rate and wage) and allocations such that individuals optimize and markets clear.\nDefine \\(\\lambda_t(a, s): A \\times S \\to [0,1]\\) to be the distribution of household over current asset \\(a\\) and state \\(s\\). Imagine it to be a matrix with each entry filled with the fraction of household with each combination of possible \\(a\\) and \\(s\\). Hypothetically, this should evolve over time following a law of motion: \\[\n\\lambda_{t+1}(a', s') = \\sum_{s \\in S} \\sum_{a: g(a,s) = a'} \\pi(s'|s) \\lambda_t(a,s), \\quad \\forall a', s'\n\\]\nwhere \\(\\pi(s'|s)\\) is the transition probability and \\(\\sum_{a: g(a,s) = a'}\\) reads that all \\(a\\) such that \\(g(a,s) = a'\\). Intuitively, the fraction of households that falls into the state \\(a'\\) and \\(s'\\) next period will be the fraction of households (with different \\(a\\) and \\(s\\)) that choose \\(a'\\) times the conditional probability that the household moves into \\(s'\\) next period.\nDoes the economy converge to some kind of steady state (stationary equilibrium)? Here, in a stationary equilibrium, \\(\\lambda_t = \\lambda, \\forall t\\) and all aggregate real quantities and prices stay constant. Aiyari (1994) proved that under some conditions, with no aggregate shock, a stationary competitive equilibrium exists for the economy. For clarity, I will formally define the stationary competitive equilibrium as follows.\nA stationary competitive equilibrium is scalars \\(\\{R, w, K, L\\}\\) and functions \\(\\{v, g, \\lambda\\}\\) such that:\n\nThe value function, \\(v\\) satisfies the Household’s problem given \\(R, w\\) and \\(l(s)\\), and \\(g\\) is an optimal policy to the problem.\n\\(\\lambda\\) is the stationary distribution that arises from \\(g\\) and \\(\\pi\\) (from above).\nAsset market clears, i.e. \\(K = \\sum_{s \\in S} \\sum_{a \\in A} \\lambda(a,s) g(a,s)\\).\nLabor market clears, i.e. \\(L = \\sum_{s \\in S} \\sum_{a \\in A} \\lambda(a,s) l(s)\\).\nFirm’s optimality conditions are satisfied.\n\nGood’s market will clear with a Walras’ Law-ish argument.\nNow let’s build towards computing the model. Add some more parameters in the struct.\n\nBase.@kwdef struct Household_GE{T1, T2, T3, R1, S}\n    β::R1 = 0.7\n    ρ::R1 = 2.0 \n    ϕ::R1 = 0.0  # The borrowing limit is zero \n    P::T1 = [0.5 0.5; 0.2 0.8] # transition matrix for state s\n    l::T2 = [1.0, 5.0] # l(s)\n    a_min::R1 = ϕ\n    a_max::R1 = 5.0\n    points::S = 10_000\n\n    a_grid::T3 = range(a_min, a_max, points)\n\n    A::R1 = 1.20\n    α::R1 = 0.7\n    δ::R1 = 1.0  #full depreciation\nend\n\nu(c, m) = c ^ (1 - m.ρ) / (1 - m.ρ)  \nuprime(c, m) = c ^ (-m.ρ) \n\nuprime (generic function with 1 method)\n\n\n\nh_GE = Household_GE()\n\nHousehold_GE{Matrix{Float64}, Vector{Float64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, Float64, Int64}(0.7, 2.0, 0.0, [0.5 0.5; 0.2 0.8], [1.0, 5.0], 0.0, 5.0, 10000, 0.0:0.0005000500050005:5.0, 1.2, 0.7, 1.0)\n\n\nIt is useful to note that at stationary equilibrium, \\(L\\) is a constant. This is because if you solve for the invariant distribution of \\(P\\) (the transition probability \\(\\pi\\) ), \\(L\\) can be written as \\(\\sum_{s \\in S} \\pi(s) l(s)\\). Here we will numerically compute \\(L\\).\n\nfunction compute_L(P, l)\n    # approximate the invariant distribution of labor endowment (inefficient)\n    temp = P^100\n    L = 0\n    for i in eachindex(l)\n        L = L + l[i] * temp[1,i] \n    end\n    return L\nend\n\ncompute_L(h_GE.P, h_GE.l)\n\n3.857142857142877\n\n\nFirst let’s compute the invariant distribution given some \\(R\\). For simplicity let \\(A\\) be 1 (not the correct way if you want to calibrate the model). Since we want to include firm’s optimality conditions, modify the function for computing \\(v\\) to include firm’s optimality condition. Now we have \\(K\\) as input and then solve for \\(R\\) and \\(w\\) endogenously.\n\nfunction solve_household_GE(h_GE; K = 0.5, v0 = zeros(length(h_GE.a_grid), length(h_GE.l)),  tol = 1e-6)\n    \n    # unpacking \n    (; a_grid, l, β, P, A, α, δ) = h_GE\n    \n    L = compute_L(P, l)\n\n    R = A * α * K^(α - 1) * L^(1 - α) + 1 - δ# Get R from the firm's first order condition\n\n    w = A * (1 - α) * K^α * L^(- α) # Get w from the firm's first order condition\n\n\n    #Given K\n\n    v1 = similar(v0)\n    pol = similar(v0, Int)\n    βv = similar(v1)\n    \n    n = length(a_grid)\n    \n    iter = 0\n    while true\n        distance = zero(eltype(v0))\n        iter += 1 \n        \n        # Precompute βE[V(a', s')] for better performance\n        for s in eachindex(l)\n            for i in eachindex(a_grid)\n                accum = zero(eltype(v0))\n                for sprime in eachindex(l)\n                    accum += β * P[s, sprime] * v0[i, sprime]\n                end\n                βv[i, s] = accum\n            end \n        end\n\n        for s in eachindex(l) \n            pol_i = 1\n            for i in eachindex(a_grid)\n                just_started = true \n                vmax = zero(eltype(v0))\n                for j in pol_i:n #take use of strictly increasing policy function\n                    c = R * a_grid[i] + w * l[s] - a_grid[j]\n                    if c &gt; 0.0\n                        v_tmp = u(c, h_GE) + βv[j, s]\n                        if just_started\n                            vmax = v_tmp\n                            pol_i = j\n                            just_started = false\n                        elseif v_tmp &gt; vmax \n                            vmax = v_tmp \n                            pol_i = j\n                        else \n                            break \n                        end \n                    end \n                end \n                v1[i, s] = vmax\n                pol[i, s] = pol_i\n                dis = abs(vmax - v0[i, s])\n                if dis &gt; distance\n                    distance = dis\n                end \n            end \n        end \n        \n        if distance &lt; tol\n            break\n        else \n            v0 .= v1\n        end \n    end \n    return (v = v1, pol = pol, h = h_GE, R = R, w = w)\nend \n    \n\nsolve_household_GE (generic function with 1 method)\n\n\n\nsol_2 = solve_household_GE(h_GE, K = 0.75)\n\n(v = [-17.561774071593458 -7.641618063043207; -17.509638148903143 -7.637543522427641; … ; -1.5204371786915847 -1.4164179272473385; -1.5203069683874395 -1.4163050174215155], pol = [1 324; 1 325; … ; 9364 9940; 9365 9941], h = Household_GE{Matrix{Float64}, Vector{Float64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, Float64, Int64}(0.7, 2.0, 0.0, [0.5 0.5; 0.2 0.8], [1.0, 5.0], 0.0, 5.0, 10000, 0.0:0.0005000500050005:5.0, 1.2, 0.7, 1.0), R = 1.3729054349841805, w = 0.11440878624868113)\n\n\n\nfunction compute_stationary_distribution(sol; tol = 1e-8, pdf_0 = fill(1.0 / prod(size(sol.v)), size(sol.v)) )\n    (; pol, h) = sol\n    \n    pdf_1 = similar(pdf_0)\n    \n    while true \n        fill!(pdf_1, zero(eltype(pdf_0)))\n        \n        for i in eachindex(h.a_grid)\n            for s in eachindex(h.l)\n                for sprime in eachindex(h.l)\n                    pdf_1[pol[i, s], sprime] += h.P[s, sprime] * pdf_0[i, s]\n                end\n            end \n        end\n        \n        distance = zero(eltype(pdf_0))\n        for (a, b) in zip(pdf_0, pdf_1)\n            distance = max(abs(a - b), distance)\n        end\n        \n        (distance &lt; tol) && break \n        pdf_0 .= pdf_1\n    end \n    return pdf_1\nend \n\ncompute_stationary_distribution (generic function with 1 method)\n\n\n\npdfA = compute_stationary_distribution(sol_2)\nplot(sol_2.h.a_grid, sum(pdfA, dims = 2)[:, 1], label = \"pdf\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOf course you can also plot the CDF.\n\nplot(sol_2.h.a_grid, cumsum(sum(pdfA, dims = 2)[:, 1]), label = \"cdf\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe can also compute the aggregate asset supply under the invariant distribution, which is simply:\n\n# function for computing A under the invariant distribution\nfunction compute_A(sol, pdf)\n    a = similar(sol.v)\n    a = sol.h.a_grid[sol.pol]\n    return a⋅pdf \nend\n\ncompute_A (generic function with 1 method)\n\n\n\n@show compute_A(sol_2, pdfA)\n\ncompute_A(sol_2, pdfA) = 1.047829596172126\n\n\n1.047829596172126\n\n\n\n\nThe capital demand and supply curve\nSince the aggregate labor supply \\(L\\) is a constant as we have argued, the only equilibrium object that has to been determined endogenously is the market clearing capital (or asset). Now, the equilibrium interest rate \\(R = AαK^{α - 1} L^{1 - α} + 1 - δ\\) is a one-to-one function of \\(K\\). The inverse function \\(K(R)\\) gives the capital demand curve, which is continuous and downward sloping. From the household problem, given each R, we can endogenously solve out the asset supply curve with the invariant distribution of household, which will be continuous and upward sloping. I denote the supply as \\(A(R)\\). The unique intersection of \\(K(R)\\) and \\(A(R)\\) gives out the equilibrium capital and the corresponding interest rate.\nThe following function solves out the aggregate asset supply and capital demand over a grid of possible equilibrium interest rate \\(R\\).\n\nfunction K_demand_supply(h_GE; R_grids = range(0.95, 1.0/h_GE.β, 100), K_demand = similar(R_grids), A_supply = similar(R_grids), w_grids = similar(R_grids))\n    (; a_grid, l, β, P, A, α, δ) = h_GE\n    L = compute_L(P, l)\n    # get the demand function\n    K_demand  = @. ((R_grids  - 1 + δ)/(A * α  * L^(1 - α)))^(1/(α - 1))\n\n    # equilibrium wages\n    w_grids = @. A^(1/(1-α)) * (1 - α) * α^(α/(1 - α)) / (R_grids - 1 + δ)^(α/(1-α))\n    # get the supply function (use the original VFI function)\n    for i in eachindex(R_grids)\n        sol = solve_household(h_GE, R = R_grids[i], w = w_grids[i])\n        pdf = compute_stationary_distribution(sol)\n        A_supply[i] = compute_A(sol, pdf)\n    end\n    return R_grids, K_demand, A_supply\nend\n\nR_grids, K_demand, A_supply = K_demand_supply(h_GE)\n\n(0.95:0.004834054834054834:1.4285714285714286, [2.5592811230762695, 2.516345927319649, 2.474342418197531, 2.4332458368040855, 2.3930322016718937, 2.353678280645201, 2.3151615639038146, 2.277460238085242, 2.2405531614551712, 2.2044198400790145  …  0.7282763869637299, 0.719867466600011, 0.7115843300746376, 0.7034246696389707, 0.695386227650787, 0.6874667953188908, 0.6796642114833356, 0.6719763614301456, 0.6644011757394387, 0.6569366291659031], [0.3935551678730847, 0.39275776490277464, 0.39199031525591366, 0.3911147352032359, 0.39089303063609615, 0.39115584409938453, 0.39160472443612426, 0.39218564845568704, 0.3928700139055018, 0.39364469678411473  …  1.2179868137367416, 1.3090272943476338, 1.4205468127468952, 1.5608866788486613, 1.7443162211259264, 1.9941783002778637, 2.3511808837319235, 2.847716210221898, 3.433878827587586, 3.958195215474183])\n\n\n\nfunction K_plot(K_demand, A_supply, h_GE; R_grids = range(0.95, 1.0/h_GE.β, 100))\n    plot(R_grids, K_demand, label = \"K(R)\")\n    plot!(R_grids, A_supply, label = \"A(R)\")\nend\n\nK_plot(K_demand, A_supply, h_GE)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe can look at when \\(A(R)\\) first exceeds \\(K(R)\\) to have a guess on the equilibrium capital and interest rate.\n\nfunction find_first(K_demand, A_supply)\n    idx = 0\n    for i in eachindex(K_demand)\n        if A_supply[i] &gt; K_demand[i]\n            idx = i\n            break\n        end\n    end\n    return idx\nend\n\ni = find_first(K_demand, A_supply)\n\nK1 = K_demand[i]\nK2 = K_demand[i - 1]\nR1 = R_grids[i - 1]\nR2 = R_grids[i]\n\nprint(\"The equilibrium capital is between $K1 and $K2. The equilibrium interest rate is between $R1 and $R2.\")\n\nThe equilibrium capital is between 0.8003704925496153 and 0.8100242546324644. The equilibrium interest rate is between 1.3415584415584416 and 1.3463924963924965.\n\n\nChallenge for solving the equilibrium:\n\n\nSolving the stationary competitive equilibrium\nNow we have everything ready to compute the stationary competitive equilibrium.\nThe algorithm goes as follows:\n\nStart from a given \\(K_0\\)\nFor each \\(K_t\\) and obtain \\(R\\) and \\(w\\)\nSolve the household problem given \\(R\\) and \\(w\\)\nCompute invariant distribution \\(\\lambda(a, s)\\)\nGet \\(A \\equiv \\sum_{s \\in S} \\sum_{a \\in A} \\lambda(a,s) g(a,s)\\).\nGuess \\(K_{t+1} = ϵ A + (1 - ϵ) K_t\\). Go back to the second step and iterate until convergence.\n\n\ncompute_A(sol_2, pdfA)\n\n1.047829596172126\n\n\n\nfunction compute_stationary_equilibrium(h_GE; K0 = 0.70, tol = 1e-5, iterate = 0, ϵ = 0.3)\n    sol = solve_household_GE(h_GE, K = K0)\n    pdf = compute_stationary_distribution(sol)\n    A = compute_A(sol, pdf)\n\n    K = K0\n    K1 = ϵ * A + (1 - ϵ) *  K\n\n    while true \n        distance = zero(eltype(K))\n        sol = solve_household_GE(h_GE, K = K)\n        pdf = compute_stationary_distribution(sol)\n        A = compute_A(sol, pdf)\n        K1 = ϵ * A + (1 - ϵ) * K # for speed\n\n        distance = abs(K1 - K)\n        (distance &lt; tol || iterate == 100) && break\n        iterate += 1\n        K = copy(K1)\n    end \n    return (K_rce = K, sol_rce = sol, iterate = iterate) \nend\n\ncompute_stationary_equilibrium (generic function with 1 method)\n\n\nWarning: this can get slow as the parameter values are casually set and the algorithms are not optimized. If you play around with the parameters you might notice that sometimes it doesn’t converge. I will discuss this with more detail.\n\n@time begin\n    sol_GE = compute_stationary_equilibrium(h_GE)\nend\n\n  0.706224 seconds (24.39 k allocations: 12.320 MiB, 2.37% compilation time)\n\n\n(K_rce = 0.807696820287375, sol_rce = (v = [-16.717896304757282 -7.336975047166834; -16.67191258870082 -7.3334192227477315; … ; -1.606486499114749 -1.490479825567775; -1.6063520123876334 -1.4903641858039804], pol = [1 337; 1 338; … ; 9198 9812; 9199 9813], h = Household_GE{Matrix{Float64}, Vector{Float64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, Float64, Int64}(0.7, 2.0, 0.0, [0.5 0.5; 0.2 0.8], [1.0, 5.0], 0.0, 5.0, 10000, 0.0:0.0005000500050005:5.0, 1.2, 0.7, 1.0), R = 1.342717011889535, w = 0.12050091789432643), iterate = 7)\n\n\n\n# equilibrium interest rate\n@show sol_GE.sol_rce.R\n\nsol_GE.sol_rce.R = 1.342717011889535\n\n\n1.342717011889535\n\n\n\n# equilibrium wage \n@show sol_GE.sol_rce.w\n\nsol_GE.sol_rce.w = 0.12050091789432643\n\n\n0.12050091789432643\n\n\n\nfunction do_pol_plot_GE(sol_1)\n\n    (; pol, h)= sol_1 \n\n    p1 = Plots.plot(xlabel = \"Current saving, a\", ylabel = \"Saving next period, a' \")\n    for s in eachindex(h.l)\n        temp = h.l[s]\n        yvals = [[h.a_grid[pol[i, s]] for i in eachindex(h.a_grid)]]\n        plot!(p1, sol_1.h.a_grid, yvals, label = \"l = $temp\")\n    end\n    \n    return p1\nend\n\n\ndo_pol_plot_GE(sol_GE.sol_rce)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWhat properties are important for solving the stationary equilibrium?\nOriginally the value that labor endowment process takes are 2 and 4, with same transition probability (now it’s 1 and 5). We can see that the algorithm for solving the stationary equilibrium doesn’t converge.\n\nh_GE1 = Household_GE(l = [2.0, 4.0])\n\nHousehold_GE{Matrix{Float64}, Vector{Float64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, Float64, Int64}(0.7, 2.0, 0.0, [0.5 0.5; 0.2 0.8], [2.0, 4.0], 0.0, 5.0, 10000, 0.0:0.0005000500050005:5.0, 1.2, 0.7, 1.0)\n\n\nLet’s look at the capital demand and supply curve. Do you notice anything different?\n\nR_grids1, K_demand1, A_supply1 = K_demand_supply(h_GE1)\nK_plot(K_demand1, A_supply1, h_GE1)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe main difference is steeper asset supply curve, especially close to where the equilibrium asset and interest rate lies. We can check if we can solve for the stationary equilibrium.\n\nsol_GE1 = compute_stationary_equilibrium(h_GE1)\n\n(K_rce = 0.689482173249647, sol_rce = (v = [-10.938373253202755 -8.118259358389057; -10.926025926801701 -8.114221970562886; … ; -1.5501109947084142 -1.4943803850038575; -1.5499807113138844 -1.4942593212902437], pol = [1 118; 1 119; … ; 9491 9788; 9492 9789], h = Household_GE{Matrix{Float64}, Vector{Float64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, Float64, Int64}(0.7, 2.0, 0.0, [0.5 0.5; 0.2 0.8], [2.0, 4.0], 0.0, 5.0, 10000, 0.0:0.0005000500050005:5.0, 1.2, 0.7, 1.0), R = 1.3591154017758917, w = 0.11713573011418807), iterate = 100)\n\n\n\n@show sol_GE1.iterate\n\nsol_GE1.iterate = 100\n\n\n100\n\n\nRecall that 100 is the upper bound we set for the total iterations. You can change it to higher value but in short you don’t get convergence. It is also often the case with other parameter choices as long as the asset supply curve is steep around where equilibrium lies around, i.e. the elasticity for interest rate is high.\nWhy this is troublesome? Now because the aggregate asset supply rises sharply where \\(R\\) is close to the equilibrium, to find an equilibrium we need good approximations of the policy function around where it matters. However recall that we used even grids for the assets, which causes inaccuracy of the policy function as we simply don’t have enough points where it truly matters. Again this is just due to approximation errors, which can be resolved from more grids around the equilibrium. One possible solution is endogenous grid methods.\nFor our purpose, we can just make the asset supply less elastic. That’s why I make the possible values of labor endowments wider. The reason this works goes back to the very nature of the “incompleteness” of the model. Household can’t insure against all future risks, so they have to save more than in a complete market due to strict concavity of utility. This is called precautionary saving. When the labor endowments get more fluctuant, either through wider values or smaller autocorrelation, the household saves more due to this motive. Fixing other parameters, households’ saving behavior is more driven by the uncertainty of the income shock.\nFor clarity, the key here lies in the comparison between the incentives to save due to precautionary saving and higher interest rate. Just for intuition, we enhanced the first channel and made the asset supply less elastic of the second.\nA final comment is that don’t be afraid when your code doesn’t work. Of course mostly it is some random mistakes and as long as you correct them, it is perfectly fine. More importantly, there are cases where something that doesn’t work actually teaches you a lesson, and often a most valuable one. Digging into some seemingly weird situations can provide valuable insights, as is the case here.\n\n\n\nTransition dynamics for incomplete market\nEconomists are often interested in the short-run response of agents given an unexpected one-time shock (often referred to as the MIT shock). Now we have the tools to compute the stationary competitive equilibrium. However as you can see, even under stationarity, this is a very complicated process.\nAssuming that households have perfect foresight over prices, this implies that household needs to know everyone else’s state today (knowing the distribution is sufficient) to infer the prices next period. In dynamic programming term, you need the whole distribution as an additional state variable. Note that the distribution is of very high dimensionality (here \\(A \\times s\\)), taking conditional expectation over this gigantic object is merely impossible.\nI put a simpler exercise based on a variation of the Hugget model in the exercise (adopted from Manuel’s problem set). One should be able to figure it out with the hints provided. I will provide a solution if you send me an email.\nKrussel Smith (1998) is a very important contribution to the computation technique of the model. They are able to show that first order approximations over prices provide very accurate results because the policy function is close to linear when \\(a\\) is not very low.\nThe latest development of the field is the sequence Jacobian. Auclert et al. provides a computation technique that is crazy fast.\n\n\nConclusion\nIncomplete market models are the workhorse models in modern Macroeconomic research, particularly in Macro-Labor and Macro-Finance. Knowing how to compute the basic model is of vital importance. In this lecture I started with the partial equilibrium version of the heteorgeneous household saving model (known as a Bewley/Hugget model), then I built towards the general equilibrium version of the model (known as an Aiyagari model). This lecture serves more as an introduction to allude readers to dive deeper themselves."
  },
  {
    "objectID": "Julia/Lectures/Julia_Lec_1_Compecon_Xing_Xu.html",
    "href": "Julia/Lectures/Julia_Lec_1_Compecon_Xing_Xu.html",
    "title": "Introduction to Julia on Computational Economics",
    "section": "",
    "text": "Xing Xu, University of Minnesota, 2023 Summer"
  },
  {
    "objectID": "Julia/Lectures/Julia_Lec_1_Compecon_Xing_Xu.html#overview",
    "href": "Julia/Lectures/Julia_Lec_1_Compecon_Xing_Xu.html#overview",
    "title": "Introduction to Julia on Computational Economics",
    "section": "Overview",
    "text": "Overview\nThe purpose of the class is to get you familiarize with some basic dynamic programming (DP) problems in economics and train you to be comfortable with coding them in Julia.\n\nWhy DP?\nDynamic programming is the key to solving modern economic models. Most macro models now are dynamic general equilibrium models. Knowing how to solve recursive models is in additional useful for searching, matching and even game theory (with sequential games).\n### Why Julia?\nJulia is the most modern tool for computations. It preserves the efficiency and clarity of coding while providing astounding speed. For comparison, c++ and Fortran are as fast but coding in them requires a lot more work as basically everything has to be built from scratch. Another extreme is Stata, which is super easy to code in (say, reg y x), but is absurdly slow and extremely limited in its applications (can’t even perform DP).\nJulia reaches a great balance and is perfectly suited for computational economics. You will see its beauty in action once you get comfortable with it.\n\n\nBackground knowledge\nI will list the backgrounds used that are considered as known. Additional knowledge will be specified when used.\nMath Preliminaries (undergraduate level knowledge is sufficient): * Linear algebra * Real analysis * Probability theory * Basic understanding of Markov Chains * Knowledge of basic optimization theory will be a plus (Sundaram &lt;A First Course in Optimization Theory&gt;)\nEconomics: * Basic choice theory (Chapter 2 MWG) (Preferences, utility representation) * Basic consumer theory (Chapter 3 MWG) (Utility maximization) * Basic producer theory (Chapter 5 MWG) * An idea of Competitive Equilibrium and Welfare Theorems (Chapter 10 MWG)\nJulia (required reading): * Setup of Julia environment, Quantecon 1 * Introduction to Julia Quantecon 2 * Julia Essentials Quantecon 3 * Arrays, Tuples, Ranges, and Other Fundamental Types Quantecon 4 * Basic understanding is good: Introduction to Types and Generic Programming Quantecon 5\nOther good references:\nNotes: * Dirk Krueger’s Macroeconomic Theory notes * Tim Kehoe’s notes on Blackwell sufficient conditions\nBooks: * Adda & Cooper &lt;Dynamic economics&gt; (strongly recommend) * Stokey, Lucas with Prescott &lt;Recursive methods in economic dynamics&gt; * Ljungqvist & Sargent &lt;Recursive Macroeconomic Theory&gt; * Heer & Maußner &lt;Dynamic General Equilibrium Modeling&gt; * Stachurski &lt;Economic Dynamics: Theory and Computation (Second Edition)&gt;\n\n\nSyllabus:\n\nLecture 1: Julia Fundamentals\nAssignment 1\n\n\nLecture 2: A canonical Neo-classical growth model and glimpse into value function iteration (VFI)\n\n\nLecture 3: McCall’s Job search model\n\n\nLecture 4: Aiyagari with transition dynamics\n\n\nLecture 5: Firm dynamics with an example of exporter dynamics"
  },
  {
    "objectID": "Julia/Lectures/Julia_Lec_1_Compecon_Xing_Xu.html#lecture-1-julia-fundamentals-1",
    "href": "Julia/Lectures/Julia_Lec_1_Compecon_Xing_Xu.html#lecture-1-julia-fundamentals-1",
    "title": "Introduction to Julia on Computational Economics",
    "section": "Lecture 1: Julia Fundamentals",
    "text": "Lecture 1: Julia Fundamentals\nThis acts as a review for Lecture 1.1 - 1.5 for Julia on Quantecon. I will only focus on stuffs we will use for the following lectures. This lecture accompanies a succinct assignment to get you familiarized with writing in the language and playing with it on the Jupyter Notebook.\n\n1.1 Packages and Projects\nWorking with packages is of vital importance in Julia. We use “LinearAlgebra” for matrix operations, “Statistics” for different distributions, “Plots” for, obviously, plots, etc. One thing you always need to keep in mind is how to download some packages.\nAfter downloading the essential packages you need, you have developed something called an “environment”. For compatibility, version control and reproducibility reasons, one often wants to create individual environments for different files. “Projects” manages each individual local environments. It will create a project repository that usually contains a “Project.toml”, a “Manifest.toml” and your code files.\n\n\n1.1.1 Packages and Projects using the Pkg API\nNow what are these exactly? Put this notebook into an individual folder and run the following lines.\n\nimport Pkg\n\n\nPkg.activate(@__DIR__)  # Activate a local environment \nPkg.add(\"LinearAlgebra\") # add the package \"LinearAlgebra\"\n\n  Activating new project at `~/Documents/Teaching/Julia course 2023 Summer/Lec1`\n    Updating registry at `~/.julia/registries/General.toml`\n   Resolving package versions...\n    Updating `~/Documents/Teaching/Julia course 2023 Summer/Lec1/Project.toml`\n  [37e2e46d] + LinearAlgebra\n    Updating `~/Documents/Teaching/Julia course 2023 Summer/Lec1/Manifest.toml`\n  [56f22d72] + Artifacts\n  [8f399da3] + Libdl\n  [37e2e46d] + LinearAlgebra\n  [e66e0078] + CompilerSupportLibraries_jll\n  [4536629a] + OpenBLAS_jll\n  [8e850b90] + libblastrampoline_jll\n\n\nYou should find two extra files in the folder. A “Project.toml” and a “Manifest.toml”. Double click on each of them in the folder or just click on them in the editor in Vscode. Take a look. What are in them?\nThe “Project.toml” file contains the name of the package, its unique UUID, its version, the authors and potential dependencies.\nThe “Manifest.toml” file shows the information for the resulting dependencies of the added packages.\nYou can check the status of your package using the following code.\n\nPkg.status()\n\n      Status `~/Documents/Teaching/Julia course 2023 Summer/Lec1/Project.toml`\n  [37e2e46d] LinearAlgebra\n\n\nSometimes you want to run other people’s code. Say you have stored some people’s project into a folder on your laptop (you just need the “Project.toml” file). To activate the exact environment, the following code will automatically download all packages and their dependencies of the same version and make it the current environment.\n\nPkg.instantiate()\n\n\n\n1.1.2 Packages and Projects using REPL\nAll the above operations can also be done using REPL (Read-Evaluate-Print-Loop).\nTo activate REPL in Vscode, press CTRL + Shift + P in Windows or CMD + Shift + P in OS, then type “start REPL” in the command palette and click on it.\nNow the Terminal should pop up and you should see “julia&gt;”. This indicates we have successfully started the REPL.\nNext type ] to enter the package mode. It should write something like “(Julia course 2023 Summer) pkg&gt;”. To exit, simply press delete.\nWith the package mode, we can perform the same functionality as before and more.\nactivate. activate the project at the current directory.\nst shows the status.\nadd LinearAlgebra add the LinearAlgebra package to the local environment.\ninstantiate automatically downloads all the missing dependencies from the particular “Project.toml”.\n\n\n1.2 Introductory example for using packages\nWe will see a lot more packages and their usages along the way. For the moment, I will show some basic functionalities of the LinearAlgebra package as an example. For more information, check here.\nFirst, you need to call the Package with “using”.\n\nusing LinearAlgebra\n\nDefine a matrix:\n\nA = [1 2 3; 4 5 6; 7 8 9]\n\n3×3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n 7  8  9\n\n\nA couple things you can do. The codes explain themselves.\n\ntr(A)\n\n15\n\n\n\ndet(A)\n\n-9.516197353929915e-16\n\n\n\ninv(A)\n\n3×3 Matrix{Float64}:\n  3.15252e15  -6.30504e15   3.15252e15\n -6.30504e15   1.26101e16  -6.30504e15\n  3.15252e15  -6.30504e15   3.15252e15\n\n\n\nnorm(A)\n\n16.881943016134134\n\n\n\neigvals(A)\n\n3-element Vector{Float64}:\n -1.1168439698070434\n -8.582743335036247e-16\n 16.11684396980703\n\n\n\neigvecs(A)\n\n3×3 Matrix{Float64}:\n -0.78583     0.408248  -0.231971\n -0.0867513  -0.816497  -0.525322\n  0.612328    0.408248  -0.818673\n\n\nI represents an identity matrix of any size. For example,\n\nA * I\n\n3×3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n 7  8  9\n\n\nThe dot product can also be calculated.\n\ndot(A, I) # Same as tr(A)\n\n15\n\n\n\nA ⋅ I\n#⋅ is typed by \"\\cdot\" then press \"tab\"\n\n15\n\n\nAsolves Ax = B. Note that this is strictly preferred to inv(A)*B. Never do the latter.\n\nB = [1, 2, 3]\nA\\B\n# or B/A\n\n3-element Vector{Float64}:\n -0.23333333333333334\n  0.46666666666666673\n  0.09999999999999994\n\n\nElement-wise operations are done through . (more discussions on this next lecture).\n\nA .+ 3\n\n3×3 Matrix{Int64}:\n  4   5   6\n  7   8   9\n 10  11  12\n\n\nYou can also perform factorizations on the matrices.\n\nlu(A)\n\nLU{Float64, Matrix{Float64}}\nL factor:\n3×3 Matrix{Float64}:\n 1.0       0.0  0.0\n 0.142857  1.0  0.0\n 0.571429  0.5  1.0\nU factor:\n3×3 Matrix{Float64}:\n 7.0  8.0        9.0\n 0.0  0.857143   1.71429\n 0.0  0.0       -1.58603e-16\n\n\n\nqr(A)\n\nLinearAlgebra.QRCompactWY{Float64, Matrix{Float64}}\nQ factor:\n3×3 LinearAlgebra.QRCompactWYQ{Float64, Matrix{Float64}}:\n -0.123091   0.904534   0.408248\n -0.492366   0.301511  -0.816497\n -0.86164   -0.301511   0.408248\nR factor:\n3×3 Matrix{Float64}:\n -8.12404  -9.60114   -11.0782\n  0.0       0.904534    1.80907\n  0.0       0.0        -8.88178e-16\n\n\n\n# Cholesky decomposition doesn't work here, which creates an error\ncholesky(A)\n\nPosDefException: PosDefException: matrix is not Hermitian; Cholesky factorization failed.\n\n\nNot surprisingly, we can also do vector operations.\n\nv1 = [1, 1, 3]\nv2 = [2, 2, 3]\n\n3-element Vector{Int64}:\n 2\n 2\n 3\n\n\n\nv1 + v2 \n# same as v1 .+ v2\n\n3-element Vector{Int64}:\n 3\n 3\n 6\n\n\nDot products for vectors are same as for matrices, except for vectors we can simply do:\n\nv1' * v2 #' for transpose\n\n13\n\n\n\ndot(v1, v2)\n\n13\n\n\n\nv1 ⋅ v2\n\n13\n\n\n\nα = 0.3\nα * 2\n\n0.6\n\n\n\n\n1.2 Functions\nIn Julia functions can be built in line or specifically calling function.\n\nf(x, y) =  x^y\nf(2,2)\n\n4\n\n\n\n#Or\nfunction f(x, y)\n    return x^y\nend\nf(2,2)\n\n4\n\n\nIf you want to input an array into f, it gives an error as it is not clear what you mean.\n\nv1 = [1, 2, 3]\nf(v1, 2)\n\nMethodError: MethodError: no method matching ^(::Vector{Int64}, ::Int64)\nClosest candidates are:\n  ^(!Matched::Union{AbstractChar, AbstractString}, ::Integer) at /Applications/Julia-1.7.app/Contents/Resources/julia/share/julia/base/strings/basic.jl:721\n  ^(!Matched::Diagonal, ::Integer) at /Applications/Julia-1.7.app/Contents/Resources/julia/share/julia/stdlib/v1.7/LinearAlgebra/src/diagonal.jl:196\n  ^(!Matched::Diagonal, ::Real) at /Applications/Julia-1.7.app/Contents/Resources/julia/share/julia/stdlib/v1.7/LinearAlgebra/src/diagonal.jl:195\n  ...\n\n\nYou can modify this by defining the function specifically for vectors.\n\nfunction g(x,y)\n    z = similar(x) # similar() generates an size/matrix of the same size and type as the input\n    for i in eachindex(x)\n        z[i] = x[i]^y\n    end\n    return z\nend\n@show g(v1, 2)\n\ng(v1, 2) = [1, 4, 9]\n\n\n3-element Vector{Int64}:\n 1\n 4\n 9\n\n\nOr in a more concise fashion,\n\ng(x,y) = [z^y for z in x] # or g(x,y) = [x[i]^y for i in eachindex(x)]\ng(v1, 2)\n\n3-element Vector{Int64}:\n 1\n 4\n 9\n\n\nInstead, you can also apply “.” to broadcast the function onto every element of v1. This comes very handy in a lot of cases.\n\nf(x, y) =  x^y\nf.(v1, 2)\n# should write f.(v1, Ref(2)) for rigidity. You can think of Ref() as fixing the input here.\n\n3-element Vector{Int64}:\n 1\n 4\n 9\n\n\n\n\n1.3 Types (a short summary)\nTypes are incredibly important for coding in Julia. It matters for the correctness, consistency and efficiency of the codes. However, my past experience told me that it is almost impossible to learn this from pure memorization. You have to actually work with them and think along the way. Here I will just let you see some commonly used types and give a simple example about declaration of types.\nFor more info on types, check the documentation.\nThe default type for (simple) integers is Int64\n\n@show typeof(1)\n\ntypeof(1) = Int64\n\n\nInt64\n\n\nThe default type for (simple) floats is Float64\n\n@show typeof(1.0) #putting \".0\" after 1 make the Julia compiler infer it is a float\n\ntypeof(1.0) = Float64\n\n\nFloat64\n\n\nThe default type for strings is String\n\n@show typeof(\"string\")\n\ntypeof(\"string\") = String\n\n\nString\n\n\nType of Boolean (true of false) variables.\n\n@show typeof(true)\n@show typeof(false)\n\ntypeof(true) = Bool\ntypeof(false) = Bool\n\n\nBool\n\n\n\n# Note that sometimes we use the feature that true is 1 and false is 0\n@show true == 1\n@show false == 0\n\ntrue == 1 = true\nfalse == 0 = true\n\n\ntrue\n\n\nWhat are the type of arrays?\n\n@show typeof([1, 2, 3])\n\ntypeof([1, 2, 3]) = Vector{Int64}\n\n\nVector{Int64} (alias for Array{Int64, 1})\n\n\n\n@show typeof([1.0, 2.0, 3.0])\n\ntypeof([1.0, 2.0, 3.0]) = Vector{Float64}\n\n\nVector{Float64} (alias for Array{Float64, 1})\n\n\nHow about the type of [1, 2.0, 3.0], where the first entry is an integer?\n\n@show typeof([1, 2.0, 3.0])\n\ntypeof([1, 2.0, 3.0]) = Vector{Float64}\n\n\nVector{Float64} (alias for Array{Float64, 1})\n\n\nNote that it returns a vector of floats. This is subtle but keep in mind that sometimes these inconsistencies can create problems. This also indicates that the type within an array is unified, to find the type of the elements in an array. We commonly use the following eltype().\n\n@show eltype([1.0, 2.0, 3.0])\n# differentiate with typeof([1.0, 2.0, 3.0])\n\neltype([1.0, 2.0, 3.0]) = Float64\n\n\nFloat64\n\n\nTuples are constructed using small brackets. We can also check the type of a tuple, which is different from the behavior of an array (vector).\n\n@show typeof((1, 2.0, 3.0, \"string\"))\n\ntypeof((1, 2.0, 3.0, \"string\")) = Tuple{Int64, Float64, Float64, String}\n\n\nTuple{Int64, Float64, Float64, String}\n\n\nNow let’s look at the function in 1.2 again, which is\n\nfunction g(x,y)\n    z = similar(x)\n    for i in eachindex(x)\n        z[i] = x[i]^y\n    end\n    return z\nend\n@show g(v1, 2)\n\n4\n\n\nIn practice, sometimes we want to specify the types of inputs, which can be down using ::.\n\nfunction g(x :: Vector{Int64},y :: Int64)\n    z = similar(x)\n    for i in eachindex(x)\n        z[i] = x[i]^y\n    end\n    return z\nend\n@show g(v1, 2)\n\ng(v1, 2) = [1, 4, 9]\n\n\n3-element Vector{Int64}:\n 1\n 4\n 9\n\n\n\ng([2], 2)\n\n1-element Vector{Int64}:\n 4\n\n\n\ng([2.0], 2)\n\nMethodError: MethodError: no method matching g(::Vector{Float64}, ::Int64)\nClosest candidates are:\n  g(!Matched::Vector{Int64}, ::Int64) at ~/Documents/Teaching/Julia course 2023 Summer/Julia_Lec_1_Compecon_Xing_Xu.ipynb:1\n\n\nHowever this sometimes creates confusions. We can input a matrix or a float and still get out results:\n\nm1 = [2 2; 2 2]\ng(m1, 2)\n\n2×2 Matrix{Int64}:\n 4  4\n 4  4\n\n\n\ng(2.0, 2) # Note that 2.0 is not even technically a vector and the output becomes a 0-dimensional Array\n\nMethodError: MethodError: no method matching g(::Float64, ::Int64)\nClosest candidates are:\n  g(!Matched::Vector{Int64}, ::Int64) at ~/Documents/Teaching/Julia course 2023 Summer/Julia_Lec_1_Compecon_Xing_Xu.ipynb:1\n\n\nThis is why Quantecon stresses the importance for generic programming. See Quantecon 5 and Quantecon 6 for details. In short, you should avoid specifying particular types unless necessary and let your codes be compatible with different types.\n\nIn addition, keep in mind that you might specify some types without even knowing that you are doing so. One example is when you want to create a vector of 0 of type Int with length 5. It is tempted to use the built-in function zeros(5). Beware that this implicitly imposes that 0s are of type float.\n\nzeros(5)\n\n5-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n\n\n\n@show eltype(zeros(5))\n\neltype(zeros(5)) = Float64\n\n\nFloat64\n\n\nSuppose you want the zeros with type int, one way is to use Int(). Again you need to broadcast it to each element.\n\nInt.(zeros(5))\n\n5-element Vector{Int64}:\n 0\n 0\n 0\n 0\n 0\n\n\nOr you can simply declare within zeros().\n\nzeros(Int,5)\n\n5-element Vector{Int64}:\n 0\n 0\n 0\n 0\n 0\n\n\n\n\n1.4 Help?\nHow do you know you can do something as zeros(Int,5)? For most built-in functions, you can find it using Help from the REPL.\nIf you haven’t quitted Vscode, you are probably still in REPL from 1.1.\nIf you have, press CTRL + Shift + P in Windows or CMD + Shift + P in OS, then type “start REPL” in the command palette and click on it. You should again see “julia&gt;”, which indicates you are at REPL.\nNow simply typing ? enters into the help mode. You should see “help?&gt;”. Let’s try with the function zeros(). Type in the zeros or zeros() and press Return on your keyboard. You should see it shows the first input of function is “[T=Float64,]”, so unless otherwise specified, zeros() will generate an array with type “Float64”.\nHelp? is usually the first place to go if you encounter some built-in functions that you are not sure with. As we go, you will be introduced to a lot more of them.\n\n\n1.5 Macros (not Macroeconomics)\nMacros are a powerful tool in Julia. Macros are a type of metaprogramming (whatever this means). Just keep in mind that Macros start with an @ and take in general expressions instead of values as inputs. You can also check with help? for documentation of each Macro.\nI know it sounds a little absurd but knowing Macros well is a ticket to becoming a Julia master. For the moment, knowing a couple examples is sufficient.\nWe have used @show to show the output of a function. However, note that the inputs it can take is much more general. Say, it can take in the function itself.\n\n@show f\n\nf = f\n\n\nf (generic function with 4 methods)\n\n\n\n@show f(1,2)\n\nf(1, 2) = 1\n\n\n1\n\n\n@time begin ... end works like tic ... tok in Matlab. It gives the duration of running the code between.\n\n@time begin\n    1 + 1\nend\n\n  0.000001 seconds\n\n\n2\n\n\nAnother example is @assert, which can be used for generating some statements if some conditions are not met.\n\nv1 = [1, 2, 3]\nv2 = [4, 5, 6]\n@assert v1 == v2 \"v1 is not equal to v2\"\n\nAssertionError: AssertionError: v1 is not equal to v2\n\n\n\n# no statement is generated if the condition is met\n@assert v1 == v1 \"v1 is not equal to v1\"\n\nA couple other useful Macros:\n@. Broadcasts . onto all arguments in one line.\n@inbounds Eliminates array bounds checking within expressions.\n@inline Performs inline Maths (more efficient).\n@view Creates a data structure that acts like an array (it is a subtype of AbstractArray ), but the underlying data is actually part of another array. Often used to create a temporary array efficiently.\nFor more, check here.\n\nj(x) = x^2\nv1 = [1,2,3]\nj.(v1)\n\n3-element Vector{Int64}:\n 1\n 4\n 9\n\n\n\n@. (j(v1) + 2)*2\n\n3-element Vector{Int64}:\n  6\n 12\n 22\n\n\n\n\n1.6 Miscellaneous facts about Julia (under construction)\nJulia has a particular behavior when assigning an array to another. What is your guess for the result of the following code?\n\nx = [3, 3]\ny = x\ny[1] = 6\n@show x\n\nOne might guess that the output will be “[3, 3]” as x is not changed. It is exactly what will happen in Python or Matlab. However, running it gives a seemingly surprising result.\n\nx = [3, 3]\ny = x\ny[1] = 6\n@show x\n\nx = [6, 3]\n\n\n2-element Vector{Int64}:\n 6\n 3\n\n\n\n# also\nx[2] = 6\n@show y\n\ny = [6, 6]\n\n\n2-element Vector{Int64}:\n 6\n 6\n\n\nThe reason is that on the background of Python or Matlab. When you run y = x, they create a copy for x in the storage and make it y. However in Julia, y = x simply assigns y to the same array that x is assigned to. That’s why changing either of them changes the other.\nThere are two alternative ways if you want the same behavior as in Python or Matlab.\n\nx = [3, 3]\ny = copy(x)\ny[1] = 6\n@show x\n\nx = [3, 3]\n\n\n2-element Vector{Int64}:\n 3\n 3\n\n\n\nx = [3, 3]\ny .= x #element-wise assignment dodges the problem\ny[1] = 6\n@show x\n\nx = [3, 3]\n\n\n2-element Vector{Int64}:\n 3\n 3\n\n\nEither one of them essentially makes y and x to be assigned to “different” arrays in your storage. If you know what a “pointer” is in c++, they now simply point to different places."
  },
  {
    "objectID": "Julia/Lectures/Julia_Lec_5_Compecon_Xing_Xu.html",
    "href": "Julia/Lectures/Julia_Lec_5_Compecon_Xing_Xu.html",
    "title": "Firm dynamics with an example of exporter dynamics",
    "section": "",
    "text": "The firm dynamics literature wants to study firms’ behavior over time. Dynamic models were developed to study firms’ entry and exit decisions, age, size distribution over time and even R& D, export and FDI decisions, etc. More recently, spatial components are incorporated to study, say, firms’ heterogeneous location choices for their subsidiaries.\nTo dig into the literature, a good starting point is Hopenhayn (1992), which provides a general theoretical framework that features uncertainty towards future profits, costly market entry and endogenous exit. The literature then expands dramatically with various focuses. Just to list a few, Klette and Kortum on innovations and firm distribution, Cooley and Quadrini (2001) on financial frictions, Das et al. (2007) on exporter dynamics."
  },
  {
    "objectID": "Julia/Lectures/Julia_Lec_5_Compecon_Xing_Xu.html#static-model-1",
    "href": "Julia/Lectures/Julia_Lec_5_Compecon_Xing_Xu.html#static-model-1",
    "title": "Firm dynamics with an example of exporter dynamics",
    "section": "Static model",
    "text": "Static model\n\nFirm side\n\nContinuum of firms indexed by i in each country\nEach firm produces a differentiated good z.\nFirm can produce domestically and set up foreign subsidiary at country j to produce.\nEach subsidiary j can sell at domestic market and export to country k.\nEach destination of export k can impose a tariff on export from country j on each variety of good \\(\\tau_{jk}(z)\\) with \\(\\tau_{ii}(z) = 0, \\forall i\\).\n\nThe profit of a MNE j from country i is sum of revenue from its domestic and foreign sales of subsidiary at country k less the input costs: \\[\n\\Pi^i_{j}(z) = \\sum_j \\delta^i_{j}(z) (1 - \\tau_{jk}(z)) p_{k}(z) y^i_{jk}(z) - w_j n^i_{j},\n\\] where \\(\\delta^i_{j}(z) = 1\\) if firm \\(z\\) in country \\(i\\) chooses to set up a subsidiary at country \\(j\\) and \\(0\\) otherwise. And\n\\[\n\\Pi^i(z) = \\sum_{j} \\Pi^i_{j}(z)\n\\] is the total profit of the MNE.\n\n\nConsumer side\nThere is a representative consumer in each country k. She has preferences over an aggregate consumption good, \\(C\\). Each index \\(z\\) denotes a differentiated variety. \\(C\\) takes the form: \\[\n    C_k = \\left(\\sum_z c_k(z)^\\frac{\\theta - 1}{\\theta} \\right)^\\frac{\\theta}{\\theta - 1},\n\\] where \\(\\theta\\) is the elasticity of substitution between varieties. The consumer maximize his utility subject to the budget constraint: \\[\n    \\sum_z c_k(z) p_k(z) = w_k n_k + T.\n\\] where\n\\[\nT = \\sum_j \\delta^i_{j}(z) (1 - \\tau_{jk}(z)) p_{k}(z) y^i_{jk}(z)\n\\]\nThe consumer takes prices as given and chooses optimal consumption \\(c(z)\\) of each variety: \\[\n    c_k(z) = (\\frac{p_k(z)}{P_k})^{-\\theta}C_k,\n\\] where P_k(z) is an aggregate price level given by: \\[\n    P_k(z) = \\left(\\sum_z p_k(z)^{1-\\theta} \\right)^{\\frac{1}{1 - \\theta}}.\n\\]"
  },
  {
    "objectID": "Julia/Assignments/Julia_PS_1_Compecon_Xing_Xu.html",
    "href": "Julia/Assignments/Julia_PS_1_Compecon_Xing_Xu.html",
    "title": "Problem set 1",
    "section": "",
    "text": "Xing Xu, University of Minnesota, 2023 Summer"
  },
  {
    "objectID": "Julia/Assignments/Julia_PS_1_Compecon_Xing_Xu.html#question-2",
    "href": "Julia/Assignments/Julia_PS_1_Compecon_Xing_Xu.html#question-2",
    "title": "Problem set 1",
    "section": "Question 2",
    "text": "Question 2\nExercise: Simple Monte-Carlo with Linear regression (taken from Amil Petrin’s Econometric class Homework)\nThis requires some basic knowledge on OLS.\nThe objective of a Monte Carlo simulation is to verify finite and large sample results. Given a model for how variables are determined, one can test the performance and properties of sample estimators by generating several samples drawn from the same population. We will operate with the following model: \\[\ny_i=\\beta_0+x_i \\beta_1+\\epsilon_i\n\\] where \\(y_i\\) and \\(x_i\\) are random variables. You observe \\(N\\) samples of \\(i=1, \\ldots, n\\) observations of \\(y\\) and \\(x\\). You will estimate: \\[\ny_i=\\hat{\\beta}_0+x_i \\hat{\\beta}_1+e_i\n\\] You will have to execute a variety of simulations, changing sample sizes, number of samples, and assumptions. 1. First assume that the \\(\\epsilon\\) and the regressors are uncorrelated. Assume that both \\(X\\) and \\(\\epsilon\\) are drawn from a normal distribution \\(\\epsilon \\sim N\\left(0, \\sigma_\\epsilon^2\\right)\\), \\(X \\sim N\\left(\\mu_x, \\sigma_x^2\\right)\\). Start with a sample size \\((n)\\) of \\(n=100\\) and define the number of samples to be simulated \\((N)\\) to be \\(N=100\\) as well. You also need to define the true values of \\(\\beta_0\\) and \\(\\beta_1\\). Report the results that you find for the means and variance-covariance matrix of \\(\\hat{\\beta}_0, \\hat{\\beta}_1\\). Finally, plot the distribution of the estimated parameters and the theoretical normal distribution that they are supposed to follow. 2. Now vary the sample size \\(n\\) and redo 1) under the new values. Report and plot your results. Comment. 3. Now vary the number of samples \\(N\\) and redo 1) under the new values. Report and plot your results. Comment. 4. Now vary the distribution of the \\(X\\) and redo 1) under the new assumptions. Report and plot your results. Comment. 5. Now set the mean of the error \\(\\epsilon\\) to be different from zero and redo 1) under the new values. Comment. 6. Now draw the \\(\\epsilon\\) in such a way that it is in fact correlated with \\(X\\) and redo 1) under the new assumptions. Report and plot your results. Comment."
  },
  {
    "objectID": "Julia/Assignments/Julia_PS_2_Compecon_Xing_Xu.html",
    "href": "Julia/Assignments/Julia_PS_2_Compecon_Xing_Xu.html",
    "title": "Question 2.1: Adding labor supply to the model.",
    "section": "",
    "text": "One natural extension to the problem is to add preferences for leisure to characterize labor supply changes.\nDenote the labor supply as \\(l_t\\). For simplicity, let household has 1 unit of labor endowment each period. Leisure can thus be denoted as \\(1 - l_t\\). Now, consider the following problem:\n\\[\\begin{align*}\n    V(k_0) \\equiv \\max_{\\{c_t, l_t, k_{t+1}\\}_{t=0}^\\infty} &\\sum_{t=0}^\\infty \\beta^t u(c_t, 1 - l_t) \\\\\n    \\text{subject to } c_t + k_{t+1} &\\leq F(k_t, l_t) + (1 - \\delta) k_t, \\forall t\\\\\n    c_t, k_{t+1} \\geq 0,& l_t \\in [0,1], \\forall t \\\\\n       \\quad k_0 &\\text{ given }\n\\end{align*}\\]\nLet the utility be denoted as:\nExercise: Find the Euler equation as before. What changed? In addition, use the FOCs from \\(c_t\\) and \\(l_t\\) to characterize the intratemporal substitution between consumption and leisure. Make some economic justifications for the results.\nThe recursive formulation of the problem is:\n\\[\\begin{align*}\n    V(k) = & \\max_{c,l, k'} \\{u(c, 1 - l) + \\beta V(k') \\}\\\\\n    \\text{subject to } & c + k' \\leq F(k, l) + (1 - \\delta) k\\\\\n    & c , k' \\geq 0, l \\in [0, 1]\n\\end{align*}\\]\nAgain, we can substitute in \\(c\\) and write the problem as the following,\n\\[\nV(k) =  \\max_{l, k' \\in \\Gamma(k)} \\{u(F(k, l) + (1 - \\delta) k - k', 1 - l) + \\beta V(k')\\}\n\\] where \\(\\Gamma(k) \\equiv \\{k', l | l \\in [0,1], k' \\in [0, F(k, l) + (1 - \\delta) k]\\}\\)\n\nSolving the problem\nLet’s specify some parameter values as before. Again we take use of struct.\n\nBase.@kwdef struct Household_labor # or simply @kwdef\n    σ :: Float64 = 2.0\n    β :: Float64 = 0.9\n    A :: Float64 = 2.0\n    α :: Float64 = 0.7\n    δ :: Float64 = 0.9\n    γ :: Float64 = 0.3 # additional parameter for the utility weight between consumption and leisure\nend\n\nh_l = Household() \n\nHousehold(2.0, 0.9, 2.0, 0.7, 0.9)\n\n\nIn addition, we need to specify the utility function and the production function. We use a separable CRRA utility for consumption and leisure. Production function is the same.\n\nu2(c,l, m) = γ * c^(1.0 - m.σ)/(1.0 - m.σ) + (1.0 - γ) * (1.0 - l)^(1.0 - m.σ)/(1.0 - m.σ)\nF2(k,l, m) = m.A * k^m.α * l^(1.0 - m.α)\n\nF2 (generic function with 1 method)\n\n\nLet’s build towards solving the model. First, note that the maximum sustainable capital is the same as before. Again, \\(F(\\tilde{k}, 1) = \\delta \\tilde{k}\\), which is \\(A \\tilde{k}^\\alpha = \\delta \\tilde{k}\\). Since \\(\\delta &gt; 0\\), \\(\\tilde{k} = (\\frac{A}{\\delta})^{\\frac{1}{1 - \\alpha}}\\). Intuitively, this is because that if we let consumption be \\(0\\) and use all labor endowment for production. The maximum sustainable level for capital in the long term will be when \\(F(\\tilde{k}, 1) = \\delta \\tilde{k}\\).\nEverything else basically follows, except that we also need to find optimal labor supply (or leisure). There are two ways to do this. You will write the codes for VFI with the algorithms provided below. Try to write all codes by yourself and check with the basic model without labor supply decisions in the lecture.\nThe brute force way of solving this starts with constructing an additional grid for labor and search over maximized value with different combinations of \\(k'\\) and \\(l\\). Since \\(l \\in [0,1]\\), we can initialize \\(l\\) with range(0.0, 1.0, 10) (10 grids for simplicity).\nThe algorithm is very similar to that in the lecture. We need an additional loop over possible values of \\(l\\). You will also need two policy functions, pol_kprime for storing optimal policy index for \\(k'\\) and \\(pol_l\\) for \\(l\\). For each combination of \\(k'\\) and \\(l\\), compute \\(c\\) and check whether it is non-negative.\nExercise: Write the function for performing VFI for the new model. Write the loop version first. After that, plot the value function and the policy function for \\(k'\\) and \\(l\\) given each \\(k\\).\nThink: does the trick with strictly increasing policy function we used in the lecture still apply here? If so how can we implement it?\nExercise: Vectorize your code as in the lecture. (partially first and try full vectorization if you are confident) Check with the result from the loop version."
  },
  {
    "objectID": "Julia/Lectures/Julia_Lec_2_Compecon_Xing_Xu.html",
    "href": "Julia/Lectures/Julia_Lec_2_Compecon_Xing_Xu.html",
    "title": "Lecture 2: A canonical Neo-classical growth model and introduction to value function iteration (VFI)",
    "section": "",
    "text": "Xing Xu, University of Minnesota, 2023 Summer"
  },
  {
    "objectID": "Julia/Lectures/Julia_Lec_2_Compecon_Xing_Xu.html#conclusion",
    "href": "Julia/Lectures/Julia_Lec_2_Compecon_Xing_Xu.html#conclusion",
    "title": "Lecture 2: A canonical Neo-classical growth model and introduction to value function iteration (VFI)",
    "section": "2.5 Conclusion",
    "text": "2.5 Conclusion\nWe have gone carefully through solving a very standard problem in Macroeconomics. The goal is to showcase how to perform basic value function iteration in Julia. We mainly talked through how to code the problem in loop version and vector version. Along the way, I showed some important features of Julia coding. Most importantly, loops, functions, struct, broadcasting and vector/matrix operations.\nAt last, we compared the performance of coding with loops and vectorizations. It might occur to you that loop version has better performance. Please keep in mind this varies in different problems and it is useful to know both methodologies."
  },
  {
    "objectID": "Julia/Lectures/Julia_Lec_3_Compecon_Xing_Xu.html",
    "href": "Julia/Lectures/Julia_Lec_3_Compecon_Xing_Xu.html",
    "title": "Lecture 3: McCall’s Job search model",
    "section": "",
    "text": "Xing Xu, University of Minnesota, 2023 Summer\nThe McCall’s job search model is a classic model and widely used as the introduction to dynamic programming due to its simplicity and flexibility. However for the consistency with Tim’s Macro class, I discuss the Neoclassical growth model first.\nIn this lecture, we will compute the basic model and add a bunch of extensions.\nMain reference:\n\nTim’s Notes\nQuantecon’s notes\n\n\n3.1 The basic setup (Largely follows from Tim’s notes)\nAn unemployed worker faces a wage offer \\(w\\) every period. We assume the cumulative distribution of the wage offer to be \\(F(v) = Prob(w \\leq v), w \\in [0, B]\\).\nThe unemployment can choose either to accept the offer and get \\(w\\) forever, or receive unemployment benefit \\(b\\) and search again.\nAn unemployed worker solves \\[\n\\max E \\sum_{t = 0}^\\infty \\beta^t y_t\n\\]\nwhere \\(y_t = \\begin{cases}\nw \\text{ if employed } \\\\\nb \\text{ if unemployed }\n\\end{cases}\\).\nThe Bellman equation for an unemployed worker is: \\[\nV(w) = \\max \\{ \\frac{w}{1 - \\beta}, b + \\beta EV(w') \\},\n\\] \\[\nV(w) = \\max \\{ \\frac{w}{1 - \\beta}, b + \\beta \\int_0^B V(w')dF(w') \\}\n\\]\n\nusing Pkg\nPkg.add([\"LaTeXStrings\", \"Statistics\", \"Distributions\", \"Expectations\"])\n\n    Updating registry at `~/.julia/registries/General.toml`\n   Resolving package versions...\n  No Changes to `~/Documents/Teaching/Julia course 2023 Summer/Project.toml`\n  No Changes to `~/Documents/Teaching/Julia course 2023 Summer/Manifest.toml`\n\n\n\nusing LaTeXStrings # For Latex String in the graph\nusing LinearAlgebra, Statistics\nusing Distributions, Expectations\nusing Random\n\n\nusing StatsPlots\n\n\n\n3.2 Theoretical derivation\nSuppose we have solved the problem and found \\(V(w)\\). Then \\[\n\\bar{V} = b + \\beta \\int_0^B V(w')dF(w')\n\\] is a constant. Let \\(\\bar{w}\\) be such that \\[\n\\frac{\\bar{w}}{1 - \\beta} = \\bar{V} = b + \\beta \\int_0^B V(w')dF(w')\n\\]\nThen we have the policy function (as an indicator) being the unemployed worker will reject the offer if \\(w &lt; \\bar{w}\\) and accept the offer if \\(w \\geq \\bar{w}\\).\nSo hypothetically, the value function should look like:\n\nw = range(0, 4.0, length=100)\nv1 = 1/(1 - 0.7) .* w\nv2 = similar(w)\nv2 .= 7.98\nv3 = [max(v1[i], v2[i]) + 0.07 for i in 1:100] # +0.07 for asthetics\nplot(w, v1, line = (:red, 1), label = L\"\\frac{w}{1 - β}\")\nplot!(w, v2, line = (:green, 1), label = L\"\\bar{V}\")\nplot!(w, v3, line = (:blue, 2.5), label = L\"V(w)\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFor formal derivations of the result check Tim’s notes.\nNow for simplicity, let the wage offer follows a discrete distribution that is uniform across the grids (this mimics the behavior of a continuous uniform distribution).\n\n\n3.3 Computing the model (VFI)\nThe steps are similar to those of the second lecture.\n\n# struct of parameters\nBase.@kwdef struct worker# or simply @kwdef\n    β :: Float64 = 0.7\n    b :: Float64 = 1.5 # unemployment benefit\n    N :: Int64 = 100\n\n    w = range(0.0, 4.0, N) # range of the distribution of wage offer \n    P :: Vector{Float64} = ones(N)./N # probability distribution\nend\n\nw_parameter = worker()\n\nworker(0.7, 1.5, 100, 0.0:0.04040404040404041:4.0, [0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01  …  0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01])\n\n\n\nfunction Mccall_discrete(w_parameter; tol = 1e-6)\n     # unpacking \n    (; β, b, N, w, P) = w_parameter\n    \n    v = ones(N)\n    pol = similar(v, Int)\n    v1 = similar(v)\n    βEv = zero(eltype(v))\n\n    iterate = 0\n\n    while true  \n        distance = zero(eltype(v))\n        \n        βEv = β * P' * v \n\n        # not very efficient\n        for i in eachindex(v1)\n            if w[i]/(1 - β) ≥ b + βEv \n                v1[i] = w[i]/(1 - β)\n                pol[i] = 2 #accepting the offer\n            else\n                v1[i] = b + βEv\n                pol[i] = 1 #rejecting the offer\n            end\n        end\n        \n        distance = maximum(abs.(v1 - v))\n\n        (distance &lt; tol || iterate == 1000) && break # break out of the whole loop if one of the statements is true\n        iterate += 1\n\n        # Vectorized update of v using element-wise assignment\n        v .= v1\n    end\n\n    return (v=v, βEv = βEv, pol=pol, iterate=iterate)\n\nend\n\nMccall_discrete (generic function with 1 method)\n\n\n\nMccall_discrete(w_parameter)\n\n(v = [7.758051209066076, 7.758051209066076, 7.758051209066076, 7.758051209066076, 7.758051209066076, 7.758051209066076, 7.758051209066076, 7.758051209066076, 7.758051209066076, 7.758051209066076  …  12.12121212121212, 12.255892255892254, 12.39057239057239, 12.525252525252524, 12.659932659932657, 12.794612794612792, 12.929292929292927, 13.063973063973062, 13.198653198653197, 13.333333333333332], βEv = 6.258051619163654, pol = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  2, 2, 2, 2, 2, 2, 2, 2, 2, 2], iterate = 18)\n\n\n\nfunction v_plot_Mccall(w_parameter)\n    w = w_parameter.w\n    (v, βEv, pol, iterate) = Mccall_discrete(w_parameter)\n    v2 = similar(w)\n    v2.= βEv + w_parameter.b\n    plot(w, w/(1 -  w_parameter.β), line = (:red, 1), label = L\"\\frac{w}{1 - β}\")\n    plot!(w, v2, line = (:green, 1), label = L\"\\bar{V}\")\n    plot!(w, v .+ 0.1, line = (:blue, 2.5), label = L\"V(w)\")\nend\n\nv_plot_Mccall(w_parameter)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFrom the graph, one can observe that with the specified parameters. The reservation wage takes the value around 2.3.\nThe simplest way to obtain it is to observe that the policy function (indexed by 1 and 2 here) jumps from not accepting to accepting at the reservation wage.\nThis can be easily implemented with the findfirst() built-in function. Of course, you can alternatively write a loop over pol and use an if to find the index and break after the condition is met.\n\nfunction Reserve_w(w_parameter)\n    w = w_parameter.w\n    (v, βEv, pol, iterate) = Mccall_discrete(w_parameter)\n    \n    idx = findfirst(==(2), pol)\n    \n    return w[idx]\nend\n\nw1 = Reserve_w(w_parameter)\n\n2.3434343434343434\n\n\n\n\n3.4 Comparative Statics\nSince the employee’s decision is solely characterized by the reservation wage, looking at the impact of changing some of the model’s parameters on the reservation wage gives us a lot of insights.\nFirst, let’s think of the impact of a change in \\(\\beta\\) will have on the reservation wage. I make \\(\\beta\\) go up from 0.7 to 0.9.\n\nw2 = Reserve_w(worker(β = 0.9)) # easy change of parameter with struct\n\n2.909090909090909\n\n\n\nw2 &gt; w1\n\ntrue\n\n\nOther things being equal, the reservation wage is higher. That is, the worker is willing to wait longer for a higher paying job. This is consistent with the typical interpretation of higher \\(\\beta\\) as being more patient.\nNext up, let’s look at a change in the unemployment benefit \\(b\\). Let’s decrease the reservation wage \\(b\\) from \\(1.5\\) to \\(1.0\\).\n\nw3 = Reserve_w(worker(b = 1.0)) # easy change of parameter with struct\n\n2.101010101010101\n\n\n\nw3 &lt; w1\n\ntrue\n\n\nA decrease in unemployment benefit results in a smaller reservation wage (and lowers worker’s welfare). Intuitively, the opportunity cost of not accepting an offer is higher. An worker is then willing to take offers that pays less. This result can be formally proven. See Tim’s Notes.\nAt last, let’s look at the effect of a mean-preserving spread of the wage distribution on the reservation wage. A mean-preserving spread is a special case of second-order stochastic dominance – namely, the special case of equal means. Let A and B be two distributions. If B is a mean-preserving spread of A, then A is second-order stochastically dominant over B; and the converse holds if A and B have equal means.\nA necessary (not sufficient) condition for mean-preserving spread is higher variance.\nHere we can easily construct a mean-preserving spread for \\(P\\) with putting equal weights only on the first and last index of \\(w\\). (with 0.5 prob., worker gets 0 and with 0.5 prob., worker gets 4)\n\nN = w_parameter.N\nP_spread = zeros(N)\nP_spread[1] = 0.5\nP_spread[N] = 0.5\nw4 = Reserve_w(worker(P = P_spread))\n\n2.8686868686868685\n\n\n\nw4 &gt; w1\n\ntrue\n\n\nIt might seem surprising at first glance that a mean preserving spread actually increases worker’s reservation wage (in this case also worker’s welfare). This is because by the setup of the problem, the worker only cares about the right-tail of the distribution - she can always decline an offer that she doesn’t like. Intuitively, the worker will prefer a wage distribution that has equal mean but higher variance. The theoretical derivation for this result can again be seen in Tim’s Notes.\n\n\n3.5 Stopping time\nWe can compute the mean stopping time of job search. This is the expected periods of an unemployed worker finding a job.\nHere since we assumed an uniform distribution. We know the probability of an unemployed worker accepting the offer each period is \\(\\frac{\\bar{w}}{4.0}\\), where \\(\\bar{w}\\) is the reservation wage. We can compute the stopping time numerically:\n\nfunction stopping_time(w_parameter, reserv_wage; repeat = 1000)\n    stop_time = zeros(Int, repeat)\n    (;w, P) = w_parameter\n    for i in 1:repeat\n        t = 0 #initialization   \n        \n        while true\n            wage = draw_wage(w, P)\n\n            if wage &lt; reserv_wage\n                t = t + 1\n            else \n                stop_time[i] = t\n                break\n            end\n        end\n    end\n    \n    return mean(stop_time)\nend\n\nfunction draw_wage(w, P)\n    # typical way of how to draw a random number from arbirtrary distribution\n    x = rand() #random number from 0 to 1\n    temp = 0.0\n    wage = zero(eltype(w))\n    for i in eachindex(P)\n        if x &gt; temp\n            temp = temp + P[i]\n        else\n            wage = w[i]\n            break\n        end\n    end\n    return wage\nend\n\ndraw_wage (generic function with 1 method)\n\n\n\nstopping_time(w_parameter, w1)\n\n1.359\n\n\n\nstopping_time(w_parameter, w2)\n\n2.512\n\n\nHolding the distribution constant, higher reservation wage implies longer waits.\n\n\n3.6 continuous distribution (follows from Quantecon)\nNow let’s add some continuous distributional assumptions for the wage offer. Check out how to work with the “Distributions” package in the first problem set.\nWith no particular reason, let the wage offer follow a Log-normal distribution with unit shape and unit scale.\nLet’s take a look at how the distribution looks like.\n\nwdist_con = LogNormal() \n\nplot(0:0.1:10, pdf.(wdist_con, 0:0.1:10), xlabel = \"wages\", ylabel = \"probabilities\", legend = false)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nwdist_con\n\nLogNormal{Float64}(μ=0.0, σ=1.0)\n\n\n\n\nChallenge: need to compute the numerical expectation\nTo solve the household problem, we need to solve for the constant \\(b + \\beta \\int_0^B V(w')dF(w')\\). However, we can’t analytically solve for \\(b + \\beta \\int_0^B V(w')dF(w')\\) as we only have a numerical approximation of \\(V(.)\\). Moreover, the computer can’t deal with continuous grids. In particular, \\(V(.)\\) has to be defined on discrete grids, so we have to numerically approximate the integral \\(\\int_0^B V(w')dF(w')\\).\nWe can use the Expectations package, which automatically finds the best algorithm to compute numerical expectations (usually Gaussian Quadrature).\n\n# struct of parameters\nBase.@kwdef struct worker_continuous \n    β :: Float64 = 0.7\n    b :: Float64 = 5 * 10^7 # unemployment benefit\n    N :: Int64 = 100\n\n    wdist_continuous :: Sampleable = LogNormal(0.0, 1.0) # root type for distributions\n    \nend\n\nw_continuous = worker_continuous()\n\nworker_continuous(0.7, 5.0e7, 100, LogNormal{Float64}(μ=0.0, σ=1.0))\n\n\n\nfunction Mccall_continuous(w_continuous; N = 100, tol = 1e-6 ,  v = zeros(N))\n     # unpacking \n    (; β, b, wdist_continuous) = w_continuous\n    \n    v1 = similar(v)\n    E = expectation(wdist_continuous; n = w_continuous.N ) # expectation operator\n    w = nodes(E) \n\n    iterate = 0\n\n    while true  \n        distance = zero(eltype(v))\n        \n        v1 = max.(w/(1 - β), b + β * E * v)\n\n        distance = maximum(abs.(v1 - v))\n        \n        (distance &lt; tol || iterate == 1000) && break # break out of the whole loop if one of the statements is true\n        iterate += 1\n\n        # Vectorized update of v using element-wise assignment\n        v .= v1\n    end\n    return (v = v, w=w, iterate = iterate)\nend\n\n\nMccall_continuous (generic function with 1 method)\n\n\n\nv, w, = Mccall_continuous(w_continuous)\n\n(v = [1.666666666666639e8, 1.666666666666639e8, 1.666666666666639e8, 1.666666666666639e8, 1.666666666666639e8, 1.666666666666639e8, 1.666666666666639e8, 1.666666666666639e8, 1.666666666666639e8, 1.666666666666639e8  …  1.666666666666639e8, 1.666666666666639e8, 1.666666666666639e8, 1.666666666666639e8, 1.666666666666639e8, 1.666666666666639e8, 1.666666666666639e8, 1.666666666666639e8, 2.5064905493460503e8, 5.714051277395748e8], w = [5.833572664144068e-9, 1.3298806708858358e-8, 2.6250326658469462e-8, 4.807794944383888e-8, 8.38914683026871e-8, 1.4137052800433642e-7, 2.3195935788611737e-7, 3.725719800588602e-7, 5.880207840756581e-7, 9.144625593480436e-7  …  1.093538483098684e6, 1.7006201601733423e6, 2.6840451067791427e6, 4.311100052669397e6, 7.073610137250996e6, 1.1920163280393668e7, 2.079955596209706e7, 3.809476403895941e7, 7.519471648038152e7, 1.7142153832187247e8], iterate = 89)\n\n\n\nv1 = 1/(1 - w_continuous.β) .* w\nv2 = similar(w)\nplot(w, v1, line = (:red, 1), label = L\"\\frac{w}{1 - β}\")\nplot!(w, ones(w_continuous.N).*v[1], line = (:green, 1), label = L\"\\bar{V}\")\nplot!(w, v .+ 0.1, line = (:blue, 2.5), label = L\"V(w)\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNot very accurate due to the setting of grids.\n\n\n3.7 Conclusion\nIn this lecture, we computed the most basic Mccall job search model. We also discussed some of the model’s properties with numerical results. Further readings for this topic on Quantecon Lecture 28 - 33 are highly recommended."
  },
  {
    "objectID": "index.html#introduction",
    "href": "index.html#introduction",
    "title": "Computational Crash Course for Economics PhD Students, Summer 2024 (UMN)",
    "section": "Introduction",
    "text": "Introduction"
  },
  {
    "objectID": "index.html#schedule",
    "href": "index.html#schedule",
    "title": "Computational Crash Course for Economics PhD Students, Summer 2024 (UMN)",
    "section": "Schedule",
    "text": "Schedule\nThe class will last three weeks from June 3rd - June 21st, 2024. There will be 6 lectures and accompanied problem sets for each language.\nHere is the proposed timeline of the lectures. All lectures will be from 9:30 am - 11:00 am CDT.\n\n\n\nJulia Lectures\nDates\n\n\n\n\nJulia Fundamentals\nTuesday, June 4th\n\n\nNeoclassical growth model (RBC)\nThursday, June 6th\n\n\nMcCall’s Job search model\nTuesday, June 11th\n\n\nIncomplete market model with heterogeneous household\nThursday, June 13th\n\n\nFirm dynamics with an example of exporter dynamics\nTuesday, June 18th\n\n\nLecture 6 (topic yet to be decided)\nThursday, June 20th\n\n\n\n(To get started with the Julia lectures, please set up with Quantecon tutorial)\n\n\n\nPython Lectures\nDates\n\n\n\n\nBasics: Conditionals, Loops, Functions, etc.\nMonday, June 3rd\n\n\nNesting, Scope, and Lists\nWednesday, June 5th\n\n\nTips & Tricks\nMonday, June 10th\n\n\nClasses and Queues\nWednesday, June 12th\n\n\nNumpy\nMonday, June 17th\n\n\nPandas\nWednesday, June 19th"
  },
  {
    "objectID": "index.html#resources-for-further-studies",
    "href": "index.html#resources-for-further-studies",
    "title": "Computational Crash Course for Economics PhD Students, Summer 2024 (UMN)",
    "section": "Resources for further studies",
    "text": "Resources for further studies\nThe go-to:\nQuantecon"
  },
  {
    "objectID": "index.html#course-overview",
    "href": "index.html#course-overview",
    "title": "Computational Crash Course for Economics PhD Students, Summer 2024 (UMN)",
    "section": "Course Overview",
    "text": "Course Overview\nThe course offerings are strategically designed to cater to varying interests and skill levels. The lectures on Julia will primarily concentrate on computational methods, demonstrating their applications across a range of classical economic models. This will involve hands-on practice with coding and implementing algorithms that are pivotal to economic analysis.\nIn contrast, the Python lectures are tailored to those new to programming. These sessions will focus on establishing a solid foundation in programming basics. Students will progressively build their skill set, culminating in the ability to tackle simple dynamic programming models. This structured approach ensures a gentle learning curve, making these lectures ideal for those who are just starting their journey in programming.\nBoth courses are structured as introductory, requiring no prior experience in programming. This accessibility is key to encouraging participation among lower year graduate students. While the courses are comprehensive, they intentionally do not delve into advanced methodologies found at the cutting edge of computational economics. Such topics are reserved for the official computational field courses offered later in the curriculum.\nIt’s important to note that the skills developed in these classes are broadly applicable and will provide a strong foundation for those interested in advancing to more specialized computational sequences. However, students already familiar with basic or intermediate programming may find the pace introductory. Thus, senior students might prefer to direct their attention towards more advanced courses that align with their existing skill levels."
  },
  {
    "objectID": "index.html#assignments",
    "href": "index.html#assignments",
    "title": "Computational Crash Course for Economics PhD Students, Summer 2024 (UMN)",
    "section": "Assignments",
    "text": "Assignments\nHere are the links to the assignments:\n\n\n\nJulia Assignments\nDue Dates\n\n\n\n\nAssignment 1\nJune 10th\n\n\nAssignment 2\nJune 12th\n\n\nAssignment 3\nJune 17th\n\n\nAssignment 4\nJune 19th\n\n\nAssignment 5\nJune 24th\n\n\nAssignment 6\nJune 26th\n\n\n\n\n\n\nPython Assignments\nDue Dates\n\n\n\n\nAssignment 1\nJune 5th\n\n\nAssignment 2\nJune 10th\n\n\nAssignment 3\nJune 12th\n\n\nAssignment 4\nJune 17th\n\n\nAssignment 5\nJune 19th\n\n\nAssignment 6\nJune 24th"
  },
  {
    "objectID": "Python/Lectures/lecture1.html",
    "href": "Python/Lectures/lecture1.html",
    "title": "Lesson 1",
    "section": "",
    "text": "Conda\n\nEnvironments\n\nImporting Packages\nVariables\n\nAssignment (using =)\n\n\nNaming\n\n\nTypes (str, int, float, bool, lists/tuples/sets, dicts)\n\n\nLists/tuples/sets and dicts\n\n\n\nFor lists/tuples: subsets, len(), sum(), max(), min(), etc.\n\n\nIf statements\n\nComparisons\n\n\nand and or\n\n\nIndentation\n\nLoops\n\nIndentation\n\n\nFor loops\n\n\nWhile loops\n\n\nBreaks\n\n\nContinue\n\nFunctions\n\nIndentation\n\n\nArguments\n\n\nReturns\n\n\nComments\n\n\n\nDocstrings\n\n\nPrinting text"
  },
  {
    "objectID": "Python/Lectures/lecture1.html#overview",
    "href": "Python/Lectures/lecture1.html#overview",
    "title": "Lesson 1",
    "section": "",
    "text": "Conda\n\nEnvironments\n\nImporting Packages\nVariables\n\nAssignment (using =)\n\n\nNaming\n\n\nTypes (str, int, float, bool, lists/tuples/sets, dicts)\n\n\nLists/tuples/sets and dicts\n\n\n\nFor lists/tuples: subsets, len(), sum(), max(), min(), etc.\n\n\nIf statements\n\nComparisons\n\n\nand and or\n\n\nIndentation\n\nLoops\n\nIndentation\n\n\nFor loops\n\n\nWhile loops\n\n\nBreaks\n\n\nContinue\n\nFunctions\n\nIndentation\n\n\nArguments\n\n\nReturns\n\n\nComments\n\n\n\nDocstrings\n\n\nPrinting text"
  },
  {
    "objectID": "Python/Lectures/lecture1.html#conda",
    "href": "Python/Lectures/lecture1.html#conda",
    "title": "Lesson 1",
    "section": "Conda",
    "text": "Conda\nDoes lots of things, we’re using it for package management\n\nEnvironments\nAllows you to keep packages organized - see here\n\nTo create: conda create --name pycourse (you can replace pycourse with any custom name)\nTo activate: conda activate pycourse\nTo install pip: conda install pip\nTo install package: pip install packagename (replace packagename with the name of the package you want to install)\n\nFor this lesson, please install: jupyterlab and/or notebook to be able to open Jupyter Notebooks (like this) (see here for more information)"
  },
  {
    "objectID": "Python/Lectures/lecture1.html#importing-packages",
    "href": "Python/Lectures/lecture1.html#importing-packages",
    "title": "Lesson 1",
    "section": "Importing Packages",
    "text": "Importing Packages\nType import packagename\n\nimport random\n\n\nprint(random.random())\n\n0.7773242780744012"
  },
  {
    "objectID": "Python/Lectures/lecture1.html#variables",
    "href": "Python/Lectures/lecture1.html#variables",
    "title": "Lesson 1",
    "section": "Variables",
    "text": "Variables\nWhy - you need to keep track of what’s what\n\nAssignment\nAssign a value to a name using = (this is not equivalent to mathematical equality, check that using ==)\n\nx = 10\nprint(x)\n\n10\n\n\n\n\nNaming\nChoose names carefully\n\nx = 10\ndistance = 10\n\n\n\nTypes\nstr, int, float, bool, lists/tuples/sets, dicts\n\ncourse_name_v1 = 'Python Course, Summer 2023'\ncourse_name_v2 = \"Python Course, Summer 2023\"\ncourse_year = 2023\nlecture_1_frac_complete = 1/5\nlecture_1_complete = False\nlectures = [1, 2, 3, 4, 5, 6, 7, 8]\nlecture_v2 = (1, 2, 3, 4, 5, 6, 7, 8)\nlectures_v3 = {1, 2, 3, 4, 5, 6, 7, 8, 8}\nlectures_occurred = {1: 'True', 2: 'False', 3: 'False', 4: 'False', 5: 'False', 6: 'False', 7: 'False', 8: 'False'}\n\n\n\nLists/tuples/sets and dicts\nLists are mutable (they can be changed) - Access an element using list[index] (indexing starts at 0)\nTuples are immutable (they cannot be changed) - Access an element using tuple[index] (indexing starts at 0)\nSets don’t have an order\nDicts work like a dictionary (a term called a ‘key’ will be linked to an associated variable called a ‘value’) - Access a value using dict[key]\n\nprint(lectures)\nlectures[0] = 0\nprint(lectures)\n\n[1, 2, 3, 4, 5, 6, 7, 8]\n[0, 2, 3, 4, 5, 6, 7, 8]\n\n\n\nprint(lecture_v2)\nlecture_v2[0] = 0\n\n(1, 2, 3, 4, 5, 6, 7, 8)\n\n\nTypeError: 'tuple' object does not support item assignment\n\n\n\nprint(lectures_v3)\nlectures_v3[0] = 0\n\n{1, 2, 3, 4, 5, 6, 7, 8}\n\n\nTypeError: 'set' object does not support item assignment\n\n\n\nlectures_occurred = {1: 'True', 2: 'False', 3: 'False', 4: 'False', 5: 'False', 6: 'False', 7: 'False', 8: 'False'}\nprint(lectures_occurred)\nlectures_occurred[0] = False\nprint(lectures_occurred)\nlectures_occurred['word'] = 'definition'\nprint(lectures_occurred)\n\n{1: 'True', 2: 'False', 3: 'False', 4: 'False', 5: 'False', 6: 'False', 7: 'False', 8: 'False'}\n{1: 'True', 2: 'False', 3: 'False', 4: 'False', 5: 'False', 6: 'False', 7: 'False', 8: 'False', 0: False}\n{1: 'True', 2: 'False', 3: 'False', 4: 'False', 5: 'False', 6: 'False', 7: 'False', 8: 'False', 0: False, 'word': 'definition'}\n\n\n\n\nFor lists/tuples: subsets, len(), sum(), max(), min(), etc.\nAccess a subset of a list/tuple using list[a: b]/tuple[a: b], which gives you the elements starting and index a and ending at index b-1 (remember that indexing starts at 0)\n\nlectures\n\n[0, 2, 3, 4, 5, 6, 7, 8]\n\n\n\nprint('Subset of list:', lectures[2: 4])\nprint('Length of list:', len(lectures))\nprint('Max of tuple:', max(lecture_v2))\nprint('Min of tuple:', min(lecture_v2))\n\nSubset of list: [3, 4]\nLength of list: 8\nMax of tuple: 8\nMin of tuple: 1"
  },
  {
    "objectID": "Python/Lectures/lecture1.html#if-statements",
    "href": "Python/Lectures/lecture1.html#if-statements",
    "title": "Lesson 1",
    "section": "If statements",
    "text": "If statements\nIf you want a task to occur under certain conditions\n\nComparisons\n\n== for equality\n!= for inequality\n&gt; or &lt; for strict inequality\n&gt;= or &lt;= for weak inequality\nin for list membership\n\n\nx != 10\n\nFalse\n\n\n\nif x == 8:\n    print('x is 8')\nelif x == 9:\n    print('x is 9')\nelse:\n    print('x is neither 8 nor 9')\n\nx is neither 8 nor 9\n\n\n\n\nand and or\nCombine statements with and and or\n\nif (x &gt;= 0) and (x &lt; 20):\n    print('x is in [0, 20)')\n\nx is in [0, 20)\n\n\n\nif 0 &lt;= x &lt; 20:\n    print('x is in [0, 20)')\n\nx is in [0, 20)\n\n\n\n\nIndentation\nMake sure the code inside the if statement is properly indented (4 spaces)"
  },
  {
    "objectID": "Python/Lectures/lecture1.html#loops",
    "href": "Python/Lectures/lecture1.html#loops",
    "title": "Lesson 1",
    "section": "Loops",
    "text": "Loops\nIf you want to repeat a task\n\nIndentation\nMake sure the code inside the loop is properly indented (4 spaces)\n\n\nFor loops\nIterate through the elements of a list/tuple/etc\n\n# List/tuple\nfor lecture in lectures:\n    print('Lecture:', lecture)\n\nLecture: 0\nLecture: 2\nLecture: 3\nLecture: 4\nLecture: 5\nLecture: 6\nLecture: 7\nLecture: 8\n\n\n\nlectures_occurred.items()\n\ndict_items([(1, 'True'), (2, 'False'), (3, 'False'), (4, 'False'), (5, 'False'), (6, 'False'), (7, 'False'), (8, 'False'), (0, False), ('word', 'definition')])\n\n\n\n# Dict\nfor lecture, lecture_occurred in lectures_occurred.items():\n    print(f'Lecture {lecture} occurred: {lecture_occurred}')\n\nLecture 1 occurred: True\nLecture 2 occurred: False\nLecture 3 occurred: False\nLecture 4 occurred: False\nLecture 5 occurred: False\nLecture 6 occurred: False\nLecture 7 occurred: False\nLecture 8 occurred: False\nLecture 0 occurred: False\nLecture word occurred: definition\n\n\n\nlen(lectures)\n\n8\n\n\n\n# Range\nfor i in range(len(lectures)):\n    print(f'Loop {i}, lecture {lectures[i]}')\n\nLoop 0, lecture 0\nLoop 1, lecture 2\nLoop 2, lecture 3\nLoop 3, lecture 4\nLoop 4, lecture 5\nLoop 5, lecture 6\nLoop 6, lecture 7\nLoop 7, lecture 8\n\n\n\n# Enumerate\nfor i, lecture in enumerate(lectures):\n    print(f'Loop {i}, lecture {lecture}')\n\nLoop 0, lecture 0\nLoop 1, lecture 2\nLoop 2, lecture 3\nLoop 3, lecture 4\nLoop 4, lecture 5\nLoop 5, lecture 6\nLoop 6, lecture 7\nLoop 7, lecture 8\n\n\n\n\nWhile loops\nIterate as long as some condition holds\n\ni = 0\nwhile i &lt; 10:\n    print(i)\n    i += 1\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n\nBreaks\nAn alternative way to get out of loops\n\ni = 0\nwhile True:\n    print(i)\n    i += 1\n    if i &gt;= 10:\n        break\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n\nContinue\nIf you want an if statement for clarity, but you don’t want it to do anything\n\nfor i, lecture in enumerate(lectures):\n    print(i)\n    if lecture == 3:\n        continue\n    else:\n        print('This is not lecture 3')\n\n0\nThis is not lecture 3\n1\nThis is not lecture 3\n2\n3\nThis is not lecture 3\n4\nThis is not lecture 3\n5\nThis is not lecture 3\n6\nThis is not lecture 3\n7\nThis is not lecture 3"
  },
  {
    "objectID": "Python/Lectures/lecture1.html#functions",
    "href": "Python/Lectures/lecture1.html#functions",
    "title": "Lesson 1",
    "section": "Functions",
    "text": "Functions\nA simple way to repeat a task\n\nIndentation\nMake sure the code inside the function is properly indented (4 spaces)\n\n\nArguments\nThe input the function requires to run (equivalent to the arguments of a mathematical function)\n\n\nReturns\nWhat the function produces after it runs\n\n\nComments\nExplain what you code is doing (put # before a single-line comment, or wrap a multi-line comment in triple quotes ''')\n\nDocstrings\nDetail at the top of the function what it does, what the arguments are, and what it returns\n\ndef square_x(x):\n    '''\n    Return the square of x.\n    \n    Arguments:\n        x (float): value to square\n        \n    Returns:\n        (float): square of x\n    '''\n    return x ** 2\n\ndef list_mean(lst):\n    '''\n    Return the mean of a list of numbers.\n    \n    Arguments:\n        lst (list): list to compute the mean of\n        \n    Returns:\n        (float): mean value of lst\n    '''\n    lst_sum = 0\n    lst_len = 0\n    for val in lst:\n        # Add values to sum\n        lst_sum += val\n        # Update length of list\n        lst_len += 1\n    # Compute mean value in lst\n    return lst_sum / lst_len\n\ndef list_mean_v2(lst):\n    '''\n    Return the mean of a list of numbers.\n    \n    Arguments:\n        lst (list): list to compute the mean of\n        \n    Returns:\n        (float): mean value of lst\n    '''\n    return sum(lst) / len(lst)\n\ndef list_mean_v3(lst1, lst2):\n    '''\n    Return the mean of the means of two lists of numbers.\n    \n    Arguments:\n        lst1 (list): list 1 to compute the mean of\n        lst2 (list): list 2 to compute the mean of\n\n    Returns:\n        (float): mean value of mean values of lst1 and lst2\n    '''\n    return (list_mean_v2(lst1) + list_mean_v2(lst2)) / 2\n\n\nsquare_x(10)\n\n100\n\n\n\nlist_mean([2, 7, 10])\n\n6.333333333333333\n\n\n\nlist_mean_v2([2, 7, 10])\n\n6.333333333333333\n\n\n\nlist_mean_v3([2, 7, 10], [5, 12, 1])\n\n6.166666666666666"
  },
  {
    "objectID": "Python/Lectures/lecture1.html#printing-text",
    "href": "Python/Lectures/lecture1.html#printing-text",
    "title": "Lesson 1",
    "section": "Printing text",
    "text": "Printing text\nLook throughout for examples, but primarily use f:\n\nprint(f'This is an f statement, so we can print variables like lists: {lectures} or dicts: {lectures_occurred} easily')\n\nThis is an f statement, so we can print variables like lists: [0, 2, 3, 4, 5, 6, 7, 8] or dicts: {1: 'True', 2: 'False', 3: 'False', 4: 'False', 5: 'False', 6: 'False', 7: 'False', 8: 'False', 0: False, 'word': 'definition'} easily\n\n\nFor simple cases, use commas (this is not as clean for complicated examples):\n\nprint('Lectures:', lectures)\n\nLectures: [0, 2, 3, 4, 5, 6, 7, 8]"
  },
  {
    "objectID": "Python/Lectures/lecture5.html",
    "href": "Python/Lectures/lecture5.html",
    "title": "Lesson 5",
    "section": "",
    "text": "NumPy"
  },
  {
    "objectID": "Python/Lectures/lecture5.html#overview",
    "href": "Python/Lectures/lecture5.html#overview",
    "title": "Lesson 5",
    "section": "",
    "text": "NumPy"
  },
  {
    "objectID": "Python/Lectures/lecture5.html#numpy",
    "href": "Python/Lectures/lecture5.html#numpy",
    "title": "Lesson 5",
    "section": "NumPy",
    "text": "NumPy\nVectors/arrays/matrices in Python.\n\nimport numpy as np\n\n\na = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]\n\n\nb = np.array(a)\n\n\nb * b\n\narray([[ 1,  4],\n       [ 9, 16]])\n\n\n\nb @ b\n\narray([[ 7, 10],\n       [15, 22]])\n\n\n\nnp.linalg.inv(b) @ b\n\narray([[1.00000000e+00, 0.00000000e+00],\n       [2.22044605e-16, 1.00000000e+00]])\n\n\n\nzeros/ones\n\na = np.ones(100)\na\n\narray([1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,\n       1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,\n       1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,\n       1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,\n       1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,\n       1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.])\n\n\n\na = np.zeros((5, 10))\na\n\narray([[0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]])\n\n\n\n\nAccessing elements/slicing/indexing\n\na[0][0]\n\n1\n\n\n\nb[0, 0]\n\n1\n\n\n\nidx = (0, 0)\nb[idx]\n\n1\n\n\n\na[idx]\n\nTypeError: list indices must be integers or slices, not tuple\n\n\n\na[:1]\n\n[[1, 2]]\n\n\n\nb\n\narray([[1, 2, 3],\n       [4, 5, 6],\n       [7, 8, 9]])\n\n\n\nb[:, [0, 2]][[0, 2], :]\n\narray([[1, 3],\n       [7, 9]])\n\n\n\na = rng.normal(size=1000)\nb = rng.integers(1000, size=50)\n\n\nb\n\narray([854,  55, 721, 913, 582, 439, 713, 117, 541, 820, 156, 623, 870,\n       966, 450, 282, 695, 531, 311, 678, 634, 645, 638, 191, 864, 611,\n       780,  71, 855, 821, 675,  97, 334, 291, 375, 484, 908, 241,  55,\n       878, 874, 752, 142,  44, 140, 563, 856, 566, 142, 274])\n\n\n\na[b]\n\narray([ 0.2689581 ,  1.41934817,  1.57621281,  1.139808  , -1.76639489,\n        0.81610715,  0.38888301,  1.71726308,  1.14546214,  0.8108156 ,\n       -0.67623437, -1.41618068, -0.60233814,  0.56134346, -0.35607535,\n       -0.98763303,  0.65829702,  1.63569133, -0.01772804,  0.19893244,\n       -1.54752077, -0.31806732,  0.14708579,  0.08111794, -0.6938663 ,\n        0.26720002,  0.03590914, -0.87805471,  2.37575881, -2.2908119 ,\n        0.88363284,  1.46243824, -0.17557353, -0.49139499, -0.69848635,\n       -0.47201708, -0.85016032, -0.0994117 ,  1.41934817, -0.02496758,\n        0.97252838,  0.26191014,  0.03688618, -0.58286632,  0.2434175 ,\n       -0.92525986, -1.0388805 , -1.73462436,  0.03688618,  0.5394642 ])\n\n\n\n\nTranspose\n\nnp.transpose(b, [1, 0])\n\narray([[1, 4, 7],\n       [2, 5, 8],\n       [3, 6, 9]])\n\n\n\n\nTile and repeat\n\nc = np.arange(3)\nc\n\narray([0, 1, 2])\n\n\n\nnp.tile(c, 3)\n\narray([0, 1, 2, 0, 1, 2, 0, 1, 2])\n\n\n\nnp.tile(c, (3, 2))\n\narray([[0, 1, 2, 0, 1, 2],\n       [0, 1, 2, 0, 1, 2],\n       [0, 1, 2, 0, 1, 2]])\n\n\n\nnp.repeat(c, 3)\n\narray([0, 0, 0, 1, 1, 1, 2, 2, 2])\n\n\n\nnp.repeat(c, (1, 2, 3))\n\narray([0, 1, 1, 2, 2, 2])\n\n\n\n\nBroadcasting\n\nc2 = np.tile(c, (3, 1))\nc2\n\narray([[0, 1, 2],\n       [0, 1, 2],\n       [0, 1, 2]])\n\n\n\nb\n\narray([[1, 2, 3],\n       [4, 5, 6],\n       [7, 8, 9]])\n\n\n\nc2 * b\n\narray([[ 0,  2,  6],\n       [ 0,  5, 12],\n       [ 0,  8, 18]])\n\n\n\nc[None, :] * b\n\narray([[ 0,  2,  6],\n       [ 0,  5, 12],\n       [ 0,  8, 18]])\n\n\n\nc2.T * b\n\narray([[ 0,  0,  0],\n       [ 4,  5,  6],\n       [14, 16, 18]])\n\n\n\nc[:, None] * b\n\narray([[ 0,  0,  0],\n       [ 4,  5,  6],\n       [14, 16, 18]])\n\n\n\nc\n\narray([0, 1, 2])\n\n\n\nc.shape\n\n(3,)\n\n\n\nc[:, None] + c[None, :]\n\narray([[0, 1, 2],\n       [1, 2, 3],\n       [2, 3, 4]])\n\n\n\n\ndiff\n\na = rng.normal(size=100000)\na\n\narray([-0.63772837, -0.26732566, -1.21791619, ...,  0.1078897 ,\n       -0.31508546,  1.53632125])\n\n\n\n%%timeit\na[1:] - a[: -1]\n\n26.7 µs ± 82.2 ns per loop (mean ± std. dev. of 7 runs, 10,000 loops each)\n\n\n\n%%timeit\nnp.diff(a)\n\n28.7 µs ± 295 ns per loop (mean ± std. dev. of 7 runs, 10,000 loops each)\n\n\n\n\ncumsum\n\na = np.arange(5)\na\n\narray([0, 1, 2, 3, 4])\n\n\n\nnp.cumsum(a)\n\narray([ 0,  1,  3,  6, 10])\n\n\n\n\nargmin/argmax/argsort\n\na = rng.normal(size=100)\n\n\na.argmax()\n\n75\n\n\n\nnp.argmax([2, 2, 1])\n\n0\n\n\n\na.argmin()\n\n27\n\n\n\na.argsort()\n\narray([27, 61,  9, 40, 43, 72, 25, 60, 54, 69, 14, 48, 51, 87,  1, 53, 16,\n       91, 58,  0, 88, 79, 84, 56,  4, 78, 80, 55, 98,  2, 66,  6, 86, 52,\n        8, 15, 95, 23, 81, 39, 92, 49, 85, 30, 45, 17, 34, 11, 83, 62, 93,\n       71, 82, 37, 68, 74, 47, 65, 21, 35, 24, 41, 50, 77, 29, 99, 26, 36,\n       19,  5, 67, 42, 63, 32, 31, 20, 73,  7, 59, 57, 64, 13, 22, 28, 96,\n       70, 10, 18, 46, 89, 38, 12, 33, 90, 76, 44,  3, 94, 97, 75])\n\n\n\n\nRandom generators\n\nrng = np.random.default_rng(1)\n\n\nrng.normal(size=10)\n\narray([ 0.34558419,  0.82161814,  0.33043708, -1.30315723,  0.90535587,\n        0.44637457, -0.53695324,  0.5811181 ,  0.3645724 ,  0.2941325 ])\n\n\n\n\nSparse matrices\n\nfrom scipy.sparse import csc_matrix\n\n\nn = 100\nn_ids = 10\nids = rng.integers(n_ids, size=n)\n\n\nJ = csc_matrix((np.ones(n), (np.arange(n), ids)), shape=(n, n_ids))\n\n\nJ.todense()\n\nmatrix([[1., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n        [0., 0., 0., 0., 0., 0., 0., 0., 0., 1.],\n        [0., 0., 0., 0., 0., 0., 0., 1., 0., 0.],\n        [0., 0., 0., 0., 0., 1., 0., 0., 0., 0.],\n        [0., 0., 0., 0., 0., 0., 0., 0., 0., 1.],\n        [0., 0., 0., 0., 0., 0., 0., 1., 0., 0.],\n        [0., 0., 0., 0., 0., 1., 0., 0., 0., 0.],\n        [0., 0., 0., 0., 0., 1., 0., 0., 0., 0.],\n        [0., 0., 0., 0., 0., 0., 0., 1., 0., 0.],\n        [0., 0., 0., 1., 0., 0., 0., 0., 0., 0.],\n        [0., 0., 0., 0., 0., 1., 0., 0., 0., 0.],\n        [1., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n        [0., 0., 0., 0., 0., 0., 0., 0., 1., 0.],\n        [0., 0., 0., 1., 0., 0., 0., 0., 0., 0.],\n        [0., 0., 0., 0., 0., 0., 0., 0., 1., 0.],\n        [0., 1., 0., 0., 0., 0., 0., 0., 0., 0.],\n        [0., 1., 0., 0., 0., 0., 0., 0., 0., 0.],\n        [0., 0., 0., 0., 0., 0., 0., 1., 0., 0.],\n        [0., 0., 0., 0., 0., 0., 0., 1., 0., 0.],\n        [0., 0., 1., 0., 0., 0., 0., 0., 0., 0.],\n        [1., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n        [0., 0., 0., 0., 0., 0., 0., 0., 1., 0.],\n        [0., 0., 0., 0., 1., 0., 0., 0., 0., 0.],\n        [0., 0., 0., 0., 0., 0., 0., 1., 0., 0.],\n        [1., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n        [1., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n        [0., 0., 0., 0., 0., 0., 1., 0., 0., 0.],\n        [0., 0., 0., 1., 0., 0., 0., 0., 0., 0.],\n        [0., 0., 0., 0., 0., 0., 0., 1., 0., 0.],\n        [0., 1., 0., 0., 0., 0., 0., 0., 0., 0.],\n        [0., 0., 1., 0., 0., 0., 0., 0., 0., 0.],\n        [0., 0., 0., 0., 0., 0., 0., 1., 0., 0.],\n        [0., 0., 0., 0., 1., 0., 0., 0., 0., 0.],\n        [0., 1., 0., 0., 0., 0., 0., 0., 0., 0.],\n        [0., 0., 0., 0., 0., 0., 0., 1., 0., 0.],\n        [0., 0., 0., 0., 0., 0., 0., 0., 0., 1.],\n        [0., 0., 0., 0., 0., 0., 0., 0., 0., 1.],\n        [0., 0., 0., 1., 0., 0., 0., 0., 0., 0.],\n        [1., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n        [0., 0., 0., 0., 0., 0., 0., 1., 0., 0.],\n        [0., 0., 1., 0., 0., 0., 0., 0., 0., 0.],\n        [0., 0., 0., 0., 1., 0., 0., 0., 0., 0.],\n        [0., 0., 1., 0., 0., 0., 0., 0., 0., 0.],\n        [0., 0., 0., 0., 0., 0., 0., 1., 0., 0.],\n        [0., 0., 0., 0., 1., 0., 0., 0., 0., 0.],\n        [0., 0., 0., 0., 0., 0., 0., 0., 1., 0.],\n        [0., 0., 1., 0., 0., 0., 0., 0., 0., 0.],\n        [0., 0., 0., 0., 0., 1., 0., 0., 0., 0.],\n        [0., 0., 0., 0., 0., 0., 0., 1., 0., 0.],\n        [0., 0., 0., 0., 0., 0., 0., 1., 0., 0.],\n        [0., 0., 0., 0., 0., 0., 0., 0., 1., 0.],\n        [0., 0., 1., 0., 0., 0., 0., 0., 0., 0.],\n        [0., 0., 1., 0., 0., 0., 0., 0., 0., 0.],\n        [0., 0., 0., 1., 0., 0., 0., 0., 0., 0.],\n        [0., 0., 0., 0., 0., 0., 0., 0., 1., 0.],\n        [0., 1., 0., 0., 0., 0., 0., 0., 0., 0.],\n        [0., 0., 0., 0., 0., 0., 1., 0., 0., 0.],\n        [1., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n        [0., 0., 0., 0., 0., 0., 0., 1., 0., 0.],\n        [0., 0., 0., 1., 0., 0., 0., 0., 0., 0.],\n        [0., 0., 0., 0., 0., 0., 0., 0., 1., 0.],\n        [0., 0., 0., 0., 0., 0., 0., 0., 1., 0.],\n        [0., 0., 0., 0., 0., 0., 0., 0., 0., 1.],\n        [1., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n        [0., 0., 0., 0., 0., 0., 0., 0., 1., 0.],\n        [1., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n        [0., 0., 0., 0., 0., 0., 1., 0., 0., 0.],\n        [0., 0., 0., 0., 0., 1., 0., 0., 0., 0.],\n        [0., 0., 1., 0., 0., 0., 0., 0., 0., 0.],\n        [0., 0., 0., 0., 0., 0., 0., 0., 1., 0.],\n        [0., 0., 0., 0., 0., 0., 0., 1., 0., 0.],\n        [0., 0., 0., 0., 0., 0., 1., 0., 0., 0.],\n        [0., 0., 0., 0., 0., 0., 0., 0., 1., 0.],\n        [0., 0., 0., 0., 0., 1., 0., 0., 0., 0.],\n        [1., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n        [0., 0., 0., 0., 0., 0., 0., 0., 1., 0.],\n        [0., 0., 0., 0., 0., 0., 0., 1., 0., 0.],\n        [0., 0., 1., 0., 0., 0., 0., 0., 0., 0.],\n        [0., 1., 0., 0., 0., 0., 0., 0., 0., 0.],\n        [0., 0., 0., 0., 0., 1., 0., 0., 0., 0.],\n        [0., 0., 0., 0., 0., 0., 0., 0., 1., 0.],\n        [1., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n        [0., 0., 0., 0., 0., 1., 0., 0., 0., 0.],\n        [0., 0., 0., 1., 0., 0., 0., 0., 0., 0.],\n        [0., 0., 0., 0., 1., 0., 0., 0., 0., 0.],\n        [0., 0., 0., 0., 0., 0., 0., 0., 1., 0.],\n        [0., 0., 0., 0., 0., 0., 0., 0., 0., 1.],\n        [1., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n        [0., 0., 0., 0., 0., 0., 0., 0., 1., 0.],\n        [0., 0., 1., 0., 0., 0., 0., 0., 0., 0.],\n        [0., 0., 0., 0., 0., 0., 0., 0., 1., 0.],\n        [0., 0., 0., 1., 0., 0., 0., 0., 0., 0.],\n        [0., 0., 0., 0., 1., 0., 0., 0., 0., 0.],\n        [0., 0., 0., 1., 0., 0., 0., 0., 0., 0.],\n        [0., 0., 0., 0., 0., 0., 0., 0., 1., 0.],\n        [0., 0., 0., 0., 0., 0., 0., 0., 0., 1.],\n        [1., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n        [0., 0., 0., 0., 0., 0., 0., 0., 1., 0.],\n        [0., 0., 0., 0., 0., 0., 0., 0., 0., 1.],\n        [1., 0., 0., 0., 0., 0., 0., 0., 0., 0.]])\n\n\n\n(J.T @ J).todense()\n\nmatrix([[ 6.,  0.,  0., ...,  0.,  0.,  0.],\n        [ 0., 10.,  0., ...,  0.,  0.,  0.],\n        [ 0.,  0.,  8., ...,  0.,  0.,  0.],\n        ...,\n        [ 0.,  0.,  0., ...,  7.,  0.,  0.],\n        [ 0.,  0.,  0., ...,  0., 14.,  0.],\n        [ 0.,  0.,  0., ...,  0.,  0., 11.]])\n\n\n\n%%timeit\n(J.T @ J)\n\n702 ms ± 9.54 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\n\n\n\n\nBincount\n\nnp.bincount(ids)\n\narray([ 6, 10,  8, ...,  7, 14, 11])\n\n\n\n%%timeit\nnp.bincount(ids)\n\n19.8 ms ± 388 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)\n\n\n\n\nMatrix multiplication with diagonal matrices\n\ndef DxM(diag, m):\n    '''\n    Product of a diagonal and a matrix, i.e. take diag @ m.\n\n    Arguments:\n        diag (NumPy Array or float): diagonal entries or multiplicative factor\n        m (NumPy Array): matrix\n    '''\n    if isinstance(diag, (float, int)):\n        # If multiplicative factor\n        if diag == 1:\n            return m\n        return diag * m\n\n    # If diagonal entries\n    return (diag * m.T).T\n\ndef MxD(m, diag):\n    '''\n    Product of a matrix and a diagonal, i.e. take m @ diag.\n\n    Arguments:\n        m (NumPy Array): matrix\n        diag (NumPy Array or float): diagonal entries or multiplicative factor\n    '''\n    if isinstance(diag, (float, int)):\n        # If multiplicative factor\n        if diag == 1:\n            return m\n        return diag * m\n\n    # If diagonal entries\n    return m * diag\n\n\nn = int(3 * 1e3)\na = rng.normal(size=(n, n))\nb = rng.normal(size=n)\n\n\nnp.diag(b)\n\narray([[-0.12979449,  0.        ,  0.        , ...,  0.        ,\n         0.        ,  0.        ],\n       [ 0.        ,  1.38349557,  0.        , ...,  0.        ,\n         0.        ,  0.        ],\n       [ 0.        ,  0.        ,  0.17053631, ...,  0.        ,\n         0.        ,  0.        ],\n       ...,\n       [ 0.        ,  0.        ,  0.        , ...,  0.36049499,\n         0.        ,  0.        ],\n       [ 0.        ,  0.        ,  0.        , ...,  0.        ,\n         0.35106105,  0.        ],\n       [ 0.        ,  0.        ,  0.        , ...,  0.        ,\n         0.        ,  0.69177961]])\n\n\n\n%%timeit\nnp.diag(b) @ a\n\n650 ms ± 25.2 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\n\n\n\n%%timeit\nDxM(b, a)\n\n4.45 ms ± 150 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)\n\n\n\n%%timeit\nb[:, None] * a\n\n4.16 ms ± 138 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)\n\n\n\n%%timeit\na @ np.diag(b)\n\n630 ms ± 28.2 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\n\n\n\n%%timeit\nMxD(a, b)\n\n5.55 ms ± 105 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)\n\n\n\nDxM(b, a)\n\narray([[ 0.04305389, -0.02450608,  0.03333491, ...,  0.07252111,\n        -0.20889637, -0.06667676],\n       [-3.04643963,  0.695854  ,  1.09382668, ..., -0.3196933 ,\n        -3.23805228, -0.73283361],\n       [ 0.02401034,  0.11501715,  0.01543444, ..., -0.11485651,\n         0.10094913,  0.11068856],\n       ...,\n       [-0.81180489, -0.08033079,  0.15354346, ...,  0.27811731,\n         0.40886214,  0.05923034],\n       [-0.03913632,  0.0205819 ,  0.38672633, ...,  0.51782762,\n        -0.52494684, -0.3598065 ],\n       [-0.56939833,  0.23959058,  0.88602361, ..., -1.20676408,\n         0.2856753 ,  0.46799477]])\n\n\n\n\nNonzero\n\na = rng.binomial(1, 0.5, size=100)\na\n\narray([0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0,\n       1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1,\n       1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0,\n       0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0,\n       0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0])\n\n\n\nnp.argmax(a)\n\n1\n\n\n\nnp.nonzero(a)[0]\n\narray([ 1,  2,  3,  6,  7,  8,  9, 12, 13, 16, 18, 22, 23, 28, 32, 33, 34,\n       37, 39, 41, 42, 43, 44, 47, 48, 49, 50, 53, 60, 61, 62, 67, 71, 74,\n       78, 81, 82, 84, 86, 90, 93, 98])"
  },
  {
    "objectID": "Python/Lectures/lecture4.html",
    "href": "Python/Lectures/lecture4.html",
    "title": "Lesson 4",
    "section": "",
    "text": "Classes\nQueues\nPA3 Review"
  },
  {
    "objectID": "Python/Lectures/lecture4.html#overview",
    "href": "Python/Lectures/lecture4.html#overview",
    "title": "Lesson 4",
    "section": "",
    "text": "Classes\nQueues\nPA3 Review"
  },
  {
    "objectID": "Python/Lectures/lecture4.html#classes",
    "href": "Python/Lectures/lecture4.html#classes",
    "title": "Lesson 4",
    "section": "Classes",
    "text": "Classes\nAn easy way to store and handle “related” data/variables.\n\nclass Student():\n    def __init__(self, first_name, last_name, middle_name=None):\n        self.first_name = first_name\n        self.last_name = last_name\n        self.middle_name = middle_name\n\n    def print_name(self):\n        if self.middle_name is None:\n            print(self.first_name, self.last_name)\n        else:\n            print(self.first_name, self.middle_name, self.last_name)\n\n\nstudent1 = Student(first_name='Adam', middle_name='Alexander', last_name='Oppenheimer')\nstudent1.print_name()\n\nAdam Alexander Oppenheimer\n\n\n\nstudent2 = Student(first_name='Yutong', last_name='Zhong')\nstudent2.print_name()\n\nYutong Zhong\n\n\n\nstudent1.middle_name\n\n'Alexander'\n\n\n\nstudent1.new_variable = 10\n\n\nstudent1.new_variable\n\n10\n\n\n\nclass Classroom():\n    def __init__(self, class_number):\n        self.class_number = class_number\n        self.students = []\n\n    def add_student(self, student):\n        self.students.append(student)\n\n    def sort_students(self, order='last_name'):\n        if order == 'last_name':\n            self.students = sorted(self.students, key=lambda a: a.last_name)\n        elif order == 'first_name':\n            self.students = sorted(self.students, key=lambda a: a.first_name)\n\n    def print(self):\n        print('Class number:', self.class_number)\n        print('Students:')\n        for student in self.students:\n            student.print_name()\n\n\npython_course = Classroom(1)\npython_course.add_student(student2)\npython_course.add_student(student1)\npython_course.print()\n\nClass number: 1\nStudents:\nYutong Zhong\nAdam Alexander Oppenheimer\n\n\n\npython_course.sort_students()\npython_course.print()\n\nClass number: 1\nStudents:\nAdam Alexander Oppenheimer\nYutong Zhong\n\n\n\npython_course.add_student(61)\n\n\npython_course.sort_students()\n\nAttributeError: 'int' object has no attribute 'last_name'\n\n\n\npython_course.print()\n\nClass number: 1\nStudents:\nAdam Alexander Oppenheimer\nYutong Zhong\n\n\nAttributeError: 'int' object has no attribute 'print_name'"
  },
  {
    "objectID": "Python/Lectures/lecture4.html#queues",
    "href": "Python/Lectures/lecture4.html#queues",
    "title": "Lesson 4",
    "section": "Queues",
    "text": "Queues\nWhat goes in first comes out first.\n\nimport queue\n\na = queue.Queue()\na.put(1)\na.put(3)\na.put(2)\nprint(a.get())\nprint(a.get())\nprint(a.get())\n\n1\n3\n2\n\n\n\na.get()\n\nKeyboardInterrupt: \n\n\nPriority Queue orders based on some ranking (often the first element of a tuple). Read more about them for PA4.\n\nb = queue.PriorityQueue()\nb.put((1, 'hello'))\nb.put((3, 'goodbye'))\nb.put((2, 'waiting'))\nprint(b.get())\nprint(b.get())\nprint(b.get())\n\n(1, 'hello')\n(2, 'waiting')\n(3, 'goodbye')"
  },
  {
    "objectID": "Python/Lectures/lecture4.html#pa3-review",
    "href": "Python/Lectures/lecture4.html#pa3-review",
    "title": "Lesson 4",
    "section": "PA3 review",
    "text": "PA3 review\nQuickly review my solution"
  },
  {
    "objectID": "Python/Lectures/lecture2.html",
    "href": "Python/Lectures/lecture2.html",
    "title": "Lesson 2",
    "section": "",
    "text": "Stuff I forgot to teach\n\nAccessing substrings\n\nNesting\n\nNested loops\n\n\nNested lists/tuples/dicts/etc.\n\nScope\n\nVariables\n\n\nFunctions\n\nList index\nPA1 Review"
  },
  {
    "objectID": "Python/Lectures/lecture2.html#overview",
    "href": "Python/Lectures/lecture2.html#overview",
    "title": "Lesson 2",
    "section": "",
    "text": "Stuff I forgot to teach\n\nAccessing substrings\n\nNesting\n\nNested loops\n\n\nNested lists/tuples/dicts/etc.\n\nScope\n\nVariables\n\n\nFunctions\n\nList index\nPA1 Review"
  },
  {
    "objectID": "Python/Lectures/lecture2.html#stuff-i-forgot-to-teach",
    "href": "Python/Lectures/lecture2.html#stuff-i-forgot-to-teach",
    "title": "Lesson 2",
    "section": "Stuff I forgot to teach",
    "text": "Stuff I forgot to teach\n\nAccessing substrings\nAccess substrings as if the string is a list\n\na = 'hello'\na[3: 5]\n\n'lo'\n\n\n\na[0]\n\n'h'\n\n\n\na[2:]\n\n'llo'\n\n\n\na[-3:]\n\n'llo'"
  },
  {
    "objectID": "Python/Lectures/lecture2.html#nesting",
    "href": "Python/Lectures/lecture2.html#nesting",
    "title": "Lesson 2",
    "section": "Nesting",
    "text": "Nesting\n\nNested loops\nA loop inside a loop\nNOTE 1: Be careful about indents!\nNOTE 2: You can include if and/or while statements inside nested loops\n\nfor i in range(3):\n    for j in range(3):\n        print(f'i: {i}, j: {j}')\n\ni: 0, j: 0\ni: 0, j: 1\ni: 0, j: 2\ni: 1, j: 0\ni: 1, j: 1\ni: 1, j: 2\ni: 2, j: 0\ni: 2, j: 1\ni: 2, j: 2\n\n\n\n\nNested lists/tuples/dicts/etc.\nThe elements of the main list are lists - access sublists using brackets, then elements of sublists using brackets\n\nnested_list = [\n    ['a11', 'a12', 'a13'],\n    ['a21', 'a22', 'a23', 'a24'],\n    ['a31', 'a32', 'a33']\n]\nprint(nested_list)\n\n[['a11', 'a12', 'a13'], ['a21', 'a22', 'a23', 'a24'], ['a31', 'a32', 'a33']]\n\n\n\nprint(nested_list[1])\n\n['a21', 'a22', 'a23', 'a24']\n\n\n\nprint(nested_list[1][2])\n\na23\n\n\n\nnested_list = [\n    ['a11', 'a12', 'a13'],\n    ['a21', 'a22', 'a23', 'a24'],\n    ['a31', 'a32', 'a33'],\n    'fjls',\n    134,\n    {'a': {'c': [1, 2, 3], 'd': 123}, 'b': 2}\n]\nprint(nested_list)\n\n[['a11', 'a12', 'a13'], ['a21', 'a22', 'a23', 'a24'], ['a31', 'a32', 'a33'], 'fjls', 134, {'a': {'c': [1, 2, 3], 'd': 123}, 'b': 2}]\n\n\n\nprint(nested_list[5])\n\n{'a': {'c': [1, 2, 3], 'd': 123}, 'b': 2}\n\n\n\nprint(nested_list[5]['a'])\n\n{'c': [1, 2, 3], 'd': 123}\n\n\n\nprint(nested_list[5]['a']['d'])\n\n123"
  },
  {
    "objectID": "Python/Lectures/lecture2.html#scope",
    "href": "Python/Lectures/lecture2.html#scope",
    "title": "Lesson 2",
    "section": "Scope",
    "text": "Scope\nWhat is the effect of modifying a variable?\n\nVariables\n\na = 3\nb = a\nb = 4\nprint(f'a: {a}, b: {b}')\n\na: 3, b: 4\n\n\nVariables that are lists are actually references to where the list is stored in memory\n\na = [1, 2, 3]\nb = a\nb.append(4)\nprint('a:', a)\nprint('b:', b)\n\na: [1, 2, 3, 4]\nb: [1, 2, 3, 4]\n\n\n\nb = [1, 2, 3, 4, 5]\nprint('a:', a)\nprint('b:', b)\n\na: [1, 2, 3, 4]\nb: [1, 2, 3, 4, 5]\n\n\n\n\nCopying\n\nb = a.copy()\nb.append(5)\nprint('a:', a)\nprint('b:', b)\n\na: [1, 2, 3, 4]\nb: [1, 2, 3, 4, 5]\n\n\n\n\nFunctions\nDefining new variables inside a function is a new, smaller scope\n\na = 5\n\ndef a_to_ten():\n    a = 10\n    print('Inside function:', a)\n\nprint('Before function:', a)\na_to_ten()\nprint('After function:', a)\n\nBefore function: 5\nInside function: 10\nAfter function: 5\n\n\nCan still modify lists inside of functions (this is called in-place modification)\n\na = [1, 2, 3]\n\ndef append_4(a):\n    a.append(4)\n\nprint('Before function:', a)\nappend_4(a)\nprint('After function:', a)\n\nBefore function: [1, 2, 3]\nAfter function: [1, 2, 3, 4]\n\n\n\na = [1, 2, 3]\n\ndef append_4():\n    a.append(4)\n\nprint('Before function:', a)\nappend_4()\nprint('After function:', a)\n\nBefore function: [1, 2, 3]\nAfter function: [1, 2, 3, 4]\n\n\n\na = [1, 2, 3]\n\ndef append_4():\n    a.copy().append(4)\n\nprint('Before function:', a)\nappend_4()\nprint('After function:', a)\n\nBefore function: [1, 2, 3]\nAfter function: [1, 2, 3]\n\n\n\na = 'hello'\n\ndef append_4(a):\n    a += 'goodbye'\n    return a\n\nprint('Before function:', a)\na2 = append_4(a)\nprint('After function:', a)\nprint('a2:', a2)\n\nBefore function: hello\nAfter function: hello\na2: hellogoodbye"
  },
  {
    "objectID": "Python/Lectures/lecture2.html#list-index",
    "href": "Python/Lectures/lecture2.html#list-index",
    "title": "Lesson 2",
    "section": "List index",
    "text": "List index\nFind the index of an element in a list - useful for PA2\n\nlist1 = ['a', 'b', 'c']\nprint(list1.index('a'))\nprint(list1.index('b'))\nprint(list1.index('c'))\n\n0\n1\n2\n\n\n\nlist2 = ['a', 'b', 'c', 'a']\nprint(list2.index('a'))\n\n0\n\n\nTo get all indices for a value\n\nimport numpy as np\n\nnp.nonzero((np.array(list2) == 'a').astype(int))[0]\n\narray([0, 3])"
  },
  {
    "objectID": "Python/Lectures/lecture2.html#pa1-review",
    "href": "Python/Lectures/lecture2.html#pa1-review",
    "title": "Lesson 2",
    "section": "PA1 review",
    "text": "PA1 review\nQuickly review my solution"
  },
  {
    "objectID": "Python/Lectures/lecture3.html",
    "href": "Python/Lectures/lecture3.html",
    "title": "Lesson 3",
    "section": "",
    "text": "Tricks for functions\n\nLambda functions\n\n\nComposing functions\n\nTricks for lists\n\nSyntactic sugar\n\n\nsorted()\n\n\nzip()\n\n\nany() and all()\n\nTricks for strings\n\nlower()\n\n\nsplit()\n\n\nstrip()\n\n\nstartswith()\n\nType casting\nPA2 Review"
  },
  {
    "objectID": "Python/Lectures/lecture3.html#overview",
    "href": "Python/Lectures/lecture3.html#overview",
    "title": "Lesson 3",
    "section": "",
    "text": "Tricks for functions\n\nLambda functions\n\n\nComposing functions\n\nTricks for lists\n\nSyntactic sugar\n\n\nsorted()\n\n\nzip()\n\n\nany() and all()\n\nTricks for strings\n\nlower()\n\n\nsplit()\n\n\nstrip()\n\n\nstartswith()\n\nType casting\nPA2 Review"
  },
  {
    "objectID": "Python/Lectures/lecture3.html#tricks-for-functions",
    "href": "Python/Lectures/lecture3.html#tricks-for-functions",
    "title": "Lesson 3",
    "section": "Tricks for functions",
    "text": "Tricks for functions\n\nLambda functions\nShorthand functions for simple tasks. Especially useful for sorting (will discuss soon).\n\nsum_a_b_sq = lambda a, b: a + b ** 2\nprint(sum_a_b_sq(2, 4))\n\n18\n\n\n\n\nComposing functions\nApply multiple functions in one line. Notice *, which unpacks the list (** unpacks a dictionary).\n\na_sq_b_cubed = lambda a, b: (a ** 2, b ** 3)\nprint(sum_a_b_sq(*a_sq_b_cubed(4, 12)))\n\n2986000\n\n\n\na_sq_b_cubed(4, 12)\n\n(16, 1728)\n\n\n\n*a_sq_b_cubed(4, 12)\n\nSyntaxError: can't use starred expression here (2410165554.py, line 1)\n\n\n\ndef print_name(first_name, last_name, middle_name=''):\n    print(first_name, middle_name, last_name)\n\nprint_name(first_name='Adam', middle_name='Alexander', last_name='Oppenheimer')\nprint_name(**{'first_name': 'Adam', 'middle_name': 'Alexander', 'last_name': 'Oppenheimer'})\n\nSyntaxError: non-default argument follows default argument (1961358567.py, line 1)\n\n\n\ndef print_name(first_name, middle_name='', last_name):\n    print(first_name, middle_name, last_name)\n\nSyntaxError: non-default argument follows default argument (4160617308.py, line 1)"
  },
  {
    "objectID": "Python/Lectures/lecture3.html#tricks-for-lists",
    "href": "Python/Lectures/lecture3.html#tricks-for-lists",
    "title": "Lesson 3",
    "section": "Tricks for lists",
    "text": "Tricks for lists\n\nSyntactic sugar\nSuper convenient way to create lists (also works for dictionaries and tuples).\n\nlst = []\nfor a in range(5):\n    lst.append(a)\nprint(lst)\n\n[0, 1, 2, 3, 4]\n\n\n\n[a for a in range(5)]\n\n[0, 1, 2, 3, 4]\n\n\n\n[a if (a % 2 == 0) else 1 / a for a in range(5)]\n\n[0, 1.0, 2, 0.3333333333333333, 4]\n\n\n\n[a for a in range(5) if a != 3]\n\n[0, 1, 2, 4]\n\n\n\n[a if (a % 2 == 0) else 1 / a for a in range(5) if a != 2]\n\n[0, 1.0, 0.3333333333333333, 4]\n\n\nCan even nest syntactic sugar. Notice you order the for loops in the same order as if you were writing out the full loops.\n\n[(i, j) for i in range(3) for j in range(2)]\n\n[(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1)]\n\n\n\n[(i, j) for i in range(3) for j in range(i)]\n\n[(1, 0), (2, 0), (2, 1)]\n\n\nBe careful about some weird behavior with syntactic sugar (this can also happen with regular loops) (see https://stackoverflow.com/questions/3431676/creating-functions-or-lambdas-in-a-loop-or-comprehension).\n\n\nsorted()\nSort a list and specify the key. Notice the lambda functions to set the key for sorting.\n\nsorted([('d', 4), ('a', 1), ('r', 2)], key=lambda a: a[0])\n\n[('a', 1), ('d', 4), ('r', 2)]\n\n\n\nsorted([('d', 4), ('a', 1), ('r', 2)], key=lambda a: a[1])\n\n[('a', 1), ('r', 2), ('d', 4)]\n\n\n\n\nzip()\nCombine two lists element by element. Make sure to convert to a list for PA3.\n\nlist(zip(range(0, 5), range(5, 0, -1)))\n\n[(0, 5), (1, 4), (2, 3), (3, 2), (4, 1)]\n\n\nMake sure the lists are the same length! They’ll zip even if they aren’t!\n\nlist(zip(range(0, 7), range(5, 0, -1)))\n\n[(0, 5), (1, 4), (2, 3), (3, 2), (4, 1)]\n\n\n\nfor i in zip(range(0, 5), range(5, 0, -1)):\n    print(i)\n\n(0, 5)\n(1, 4)\n(2, 3)\n(3, 2)\n(4, 1)\n\n\n\nzipped_lst = zip(range(0, 5), range(5, 0, -1))\nfor elmt in zipped_lst:\n    print(elmt)\n    break\nfor elmt in zipped_lst:\n    print(elmt)\n    break\nprint(zipped_lst[0])\n\n(0, 5)\n(1, 4)\n\n\nTypeError: 'zip' object is not subscriptable\n\n\n\n\nany() and all()\nany(): check whether any element of a list is True.\nall(): check whether all elements of a list are True.\n\nany([True, True, False])\n\nTrue\n\n\n\nany([False, False, False])\n\nFalse\n\n\n\nall([True, True, False])\n\nFalse\n\n\n\nall([True, True, True])\n\nTrue"
  },
  {
    "objectID": "Python/Lectures/lecture3.html#tricks-for-strings",
    "href": "Python/Lectures/lecture3.html#tricks-for-strings",
    "title": "Lesson 3",
    "section": "Tricks for strings",
    "text": "Tricks for strings\n\nlower()\nConvert text to lowercase.\n\n'HELLO'.lower()\n\n'hello'\n\n\n\n\nsplit()\nSplit string into a list, dividing words by the specified character.\n\n'Hello, I am Adam.'.split(' ')\n\n['Hello,', 'I', 'am', 'Adam.']\n\n\n\n'Hello, I am Adam.'.split('m')\n\n['Hello, I a', ' Ada', '.']\n\n\n\n\nstrip()\nRemove the specified characters from the start and end of a string.\n\n'abcdefgabcdefg'.strip('bacdg')\n\n'efgabcdef'\n\n\n\n\nstartswith()\nCheck whether the string starts with the specified string.\n\n'hello'.startswith('he')\n\nTrue\n\n\n\n'hello'.startswith('hen')\n\nFalse\n\n\n\n\nType casting\nConvert between types by writing the name of the type you want to convert to and using the name as if it is a function.\n\nval = 1.0\nprint(val)\nprint(int(val))\n\n1.0\n1\n\n\n\nlst = [1, 2, 3]\nprint(lst)\nprint(tuple(lst))\n\n[1, 2, 3]\n(1, 2, 3)\n\n\n\nprint(zip(range(0, 5), range(5, 0, -1)))\nprint(list(zip(range(0, 5), range(5, 0, -1))))\n\n&lt;zip object at 0x7fd818792d80&gt;\n[(0, 5), (1, 4), (2, 3), (3, 2), (4, 1)]"
  },
  {
    "objectID": "Python/Lectures/lecture3.html#pa2-review",
    "href": "Python/Lectures/lecture3.html#pa2-review",
    "title": "Lesson 3",
    "section": "PA2 review",
    "text": "PA2 review\nQuickly review my solution"
  }
]